Index: src/broker/cas_net_buf.h
===================================================================
--- src/broker/cas_net_buf.h	(revision 6634)
+++ src/broker/cas_net_buf.h	(working copy)
@@ -44,7 +44,7 @@
 
 #if (defined(SOLARIS) && !defined(SOLARIS_X86)) || defined(HPUX) || defined(AIX) || defined(PPC_LINUX)
 #define BYTE_ORDER_BIG_ENDIAN
-#elif defined(WINDOWS) || defined(LINUX) || defined(OSF1) || defined(ALPHA_LINUX) || defined(UNIXWARE7) || defined(SOLARIS_X86)
+#elif defined(WINDOWS) || defined(LINUX) || defined(OSF1) || defined(ALPHA_LINUX) || defined(UNIXWARE7) || defined(SOLARIS_X86) || defined(MAC_OS)
 #ifdef BYTE_ORDER_BIG_ENDIAN
 #error BYTE_ORDER_BIG_ENDIAN defined
 #endif
Index: src/cci/cci_net_buf.h
===================================================================
--- src/cci/cci_net_buf.h	(revision 6634)
+++ src/cci/cci_net_buf.h	(working copy)
@@ -56,7 +56,7 @@
 
 #if (defined(SOLARIS) && !defined(SOLARIS_X86)) || defined(HPUX) || defined(AIX)
 #define BYTE_ORDER_BIG_ENDIAN
-#elif defined(WINDOWS) || defined(LINUX) || defined(SOLARIS_X86)
+#elif defined(WINDOWS) || defined(LINUX) || defined(SOLARIS_X86) || defined(MAC_OS)
 #ifdef BYTE_ORDER_BIG_ENDIAN
 #error BYTE_ORDER_BIG_ENDIAN defined
 #endif
Index: src/cci/cci_common.h
===================================================================
--- src/cci/cci_common.h	(revision 6634)
+++ src/cci/cci_common.h	(working copy)
@@ -68,7 +68,7 @@
 #define __func__		__FUNCTION__
 #define gettid()                GetCurrentThreadId()
 #else
-#define gettid()                syscall(__NR_gettid)
+#define gettid()                getpid()
 #endif
 
 #define API_SLOG(con) \
Index: src/base/porting.h
===================================================================
--- src/base/porting.h	(revision 6634)
+++ src/base/porting.h	(working copy)
@@ -347,7 +347,7 @@
 #if !defined(HAVE_DIRNAME)
   char *dirname (const char *path);
 #endif				/* HAVE_DIRNAME */
-  extern int basename_r (const char *path, char *pathbuf, size_t buflen);
+  extern int cub_basename_r (const char *path, char *pathbuf, size_t buflen);
 #if !defined(HAVE_BASENAME)
   extern char *basename (const char *path);
 #endif				/* HAVE_BASENAME */
@@ -415,7 +415,7 @@
   int cub_vsnprintf (char *buffer, size_t count, const char *format,
 		     va_list argptr);
 #endif
-#if defined(WINDOWS)
+#if defined(WINDOWS) || defined(MAC_OS)
 /* The following structure is used to generate uniformly distributed
  * pseudo-random numbers reentrantly.
  */
@@ -433,7 +433,8 @@
   extern int srand48_r (long int seedval, struct drand48_data *buffer);
   extern int lrand48_r (struct drand48_data *buffer, long int *result);
   extern int drand48_r (struct drand48_data *buffer, double *result);
-
+#endif
+#if defined(WINDOWS)
   extern double round (double d);
 
   typedef struct
@@ -681,6 +682,14 @@
 #endif				/* HAVE_GCC_ATOMIC_BUILTINS */
 
 #endif				/* WINDOWS */
+#ifndef ETIME  /* for FreeBSD */
+#include <sys/timeb.h>
+#include <unistd.h>
+#define ETIME ETIMEDOUT
+#define off64_t off_t
+#define lseek64(filedes, offset, whence) lseek(filedes, offset, whence)
+#endif
+
 #ifdef __cplusplus
 }
 #endif
Index: configure.ac
===================================================================
--- configure.ac	(revision 6634)
+++ configure.ac	(working copy)
@@ -34,7 +34,36 @@
 AC_PROG_CC
 AC_PROG_CXX
 AM_PROG_CC_C_O
+AC_PROG_LIBTOOL
+AC_PROG_RANLIB
+AC_PROG_INSTALL
+AC_PROG_YACC
+AC_PROG_LEX
+CFLAGS="$remember_CFLAGS"
+CXXFLAGS="$remember_CXXFLAGS"
+LDFLAGS="$remember_LDFLAGS"
 
+# Patch libtool to not use rpath
+sed < libtool > libtool-2 's/^hardcode_libdir_flag_spec.*$'/'hardcode_libdir_flag_spec=" -D__LIBTOOL_NO_RPATH__ "/'
+mv libtool-2 libtool
+chmod 755 libtool
+
+# System type
+SYSTEM_TYPE="$host_vendor-$host_os"
+MACHINE_TYPE="$host_cpu"
+
+case $SYSTEM_TYPE in
+	*linux*) SYS_DEFS="-DGCC -DLINUX -D_GNU_SOURCE -DI386"
+		 SYS_LIBS="" ;;
+	*)       SYS_DEFS="-DMAC_OS"
+		 SYS_LIBS="" ;;
+esac
+
+case $MACHINE_TYPE in
+	x86*|i*86)	SYS_DEFS="$SYS_DEFS -DX86" ;;
+	*)		;;
+esac
+
 # Checks bit model feature.
 AC_ARG_ENABLE([64bit],
 	[AS_HELP_STRING([--enable-64bit],
@@ -64,39 +93,8 @@
 fi
 AM_CONDITIONAL([BUILD_64], [test "$enable_64bit" = "yes"])
 
-export BIT_MODEL CC CXX
+export BIT_MODEL SYSTEM_TYPE MACHINE_TYPE CC CXX
 
-AC_PROG_LIBTOOL
-AC_PROG_RANLIB
-AC_PROG_INSTALL
-AC_PROG_YACC
-AC_PROG_LEX
-CFLAGS="$remember_CFLAGS"
-CXXFLAGS="$remember_CXXFLAGS"
-LDFLAGS="$remember_LDFLAGS"
-
-# Patch libtool to not use rpath
-sed < libtool > libtool-2 's/^hardcode_libdir_flag_spec.*$'/'hardcode_libdir_flag_spec=" -D__LIBTOOL_NO_RPATH__ "/'
-mv libtool-2 libtool
-chmod 755 libtool
-
-# System type
-SYSTEM_TYPE="$host_vendor-$host_os"
-MACHINE_TYPE="$host_cpu"
-export SYSTEM_TYPE MACHINE_TYPE
-
-case $SYSTEM_TYPE in
-	*linux*) SYS_DEFS="-DGCC -DLINUX -D_GNU_SOURCE -DI386"
-		 SYS_LIBS="" ;;
-	*)       SYS_DEFS=""
-		 SYS_LIBS="" ;;
-esac
-
-case $MACHINE_TYPE in
-	x86*|i*86)	SYS_DEFS="$SYS_DEFS -DX86" ;;
-	*)		;;
-esac
-
 # Checks for libraries.
 AC_CHECK_LIB([m], [main])
 #AC_CHECK_LIB([rt], [main])
@@ -350,7 +348,7 @@
 		[build as dbgw lib to use cci mock @<:@default=no@:>@])],
 	[enable_mock=$enableval],
 	[enable_mock=no])
-	
+
 if test "$enable_mock" = "yes"
 then
 	DBGW_DEFS="$DBGW_DEFS -DBUILD_MOCK"
Index: external/gc6.7/darwin_stop_world.c
===================================================================
--- external/gc6.7/darwin_stop_world.c	(revision 6634)
+++ external/gc6.7/darwin_stop_world.c	(working copy)
@@ -10,7 +10,7 @@
    be allocated, is called the red zone. This area as shown in Figure 3-2 may
    be used for any purpose as long as a new stack frame does not need to be
    added to the stack."
-   
+
    Page 50: "If a leaf procedure's red zone usage would exceed 224 bytes, then
    it must set up a stack frame just like routines that call other routines."
 */
@@ -32,7 +32,7 @@
 
 unsigned long FindTopOfStack(unsigned int stack_start) {
   StackFrame	*frame;
-  
+
   if (stack_start == 0) {
 # ifdef POWERPC
 #   if CPP_WORDSZ == 32
@@ -59,14 +59,14 @@
        is not set up on purpose, so we shouldn't check it. */
     if ((frame->savedLR & ~3) == 0) break; /* if the next LR is bogus, stop */
     if ((~(frame->savedLR) & ~3) == 0) break; /* ditto */
-  } while (1); 
+  } while (1);
 
 # ifdef DEBUG_THREADS
     /* GC_printf1("FindTopOfStack finish at sp = %p\n", frame); */
 # endif
 
   return (unsigned long)frame;
-}	
+}
 
 #ifdef DARWIN_DONT_PARSE_STACK
 void GC_push_all_stacks() {
@@ -79,14 +79,16 @@
   ppc_thread_state_t state;
 #elif defined(I386)
   i386_thread_state_t state;
+#elif defined(X86_64)
+  x86_thread_state64_t state;
 #else
 # error FIXME for non-x86 || ppc architectures
 #endif
   mach_msg_type_number_t thread_state_count = MACHINE_THREAD_STATE_COUNT;
-  
+
   me = pthread_self();
   if (!GC_thr_initialized) GC_thr_init();
-  
+
   for(i=0;i<THREAD_TABLE_SZ;i++) {
     for(p=GC_threads[i];p!=0;p=p->next) {
       if(p -> flags & FINISHED) continue;
@@ -100,50 +102,71 @@
 			     (natural_t*)&state,
 			     &thread_state_count);
 	if(r != KERN_SUCCESS) ABORT("thread_get_state failed");
-	
+
 #if defined(I386)
-	lo = state.esp;
+	lo = state.__esp;
 
-	GC_push_one(state.eax); 
-	GC_push_one(state.ebx); 
-	GC_push_one(state.ecx); 
-	GC_push_one(state.edx); 
-	GC_push_one(state.edi); 
-	GC_push_one(state.esi); 
-	GC_push_one(state.ebp); 
+	GC_push_one(state.__eax);
+	GC_push_one(state.__ebx);
+	GC_push_one(state.__ecx);
+	GC_push_one(state.__edx);
+	GC_push_one(state.__edi);
+	GC_push_one(state.__esi);
+	GC_push_one(state.__ebp);
+#elif defined(X86_64)
+  lo = (void *)state.THREAD_FLD(rsp);
+# ifndef DARWIN_DONT_PARSE_STACK
+    *phi = GC_FindTopOfStack(state.THREAD_FLD(rsp));
+# endif
+  GC_push_one(state.THREAD_FLD(rax));
+  GC_push_one(state.THREAD_FLD(rbx));
+  GC_push_one(state.THREAD_FLD(rcx));
+  GC_push_one(state.THREAD_FLD(rdx));
+  GC_push_one(state.THREAD_FLD(rdi));
+  GC_push_one(state.THREAD_FLD(rsi));
+  GC_push_one(state.THREAD_FLD(rbp));
+  /* GC_push_one(state.THREAD_FLD(rsp)); */
+  GC_push_one(state.THREAD_FLD(r8));
+  GC_push_one(state.THREAD_FLD(r9));
+  GC_push_one(state.THREAD_FLD(r10));
+  GC_push_one(state.THREAD_FLD(r11));
+  GC_push_one(state.THREAD_FLD(r12));
+  GC_push_one(state.THREAD_FLD(r13));
+  GC_push_one(state.THREAD_FLD(r14));
+  GC_push_one(state.THREAD_FLD(r15));
 #elif defined(POWERPC)
 	lo = (void*)(state.r1 - PPC_RED_ZONE_SIZE);
-        
-	GC_push_one(state.r0); 
-	GC_push_one(state.r2); 
-	GC_push_one(state.r3); 
-	GC_push_one(state.r4); 
-	GC_push_one(state.r5); 
-	GC_push_one(state.r6); 
-	GC_push_one(state.r7); 
-	GC_push_one(state.r8); 
-	GC_push_one(state.r9); 
-	GC_push_one(state.r10); 
-	GC_push_one(state.r11); 
-	GC_push_one(state.r12); 
-	GC_push_one(state.r13); 
-	GC_push_one(state.r14); 
-	GC_push_one(state.r15); 
-	GC_push_one(state.r16); 
-	GC_push_one(state.r17); 
-	GC_push_one(state.r18); 
-	GC_push_one(state.r19); 
-	GC_push_one(state.r20); 
-	GC_push_one(state.r21); 
-	GC_push_one(state.r22); 
-	GC_push_one(state.r23); 
-	GC_push_one(state.r24); 
-	GC_push_one(state.r25); 
-	GC_push_one(state.r26); 
-	GC_push_one(state.r27); 
-	GC_push_one(state.r28); 
-	GC_push_one(state.r29); 
-	GC_push_one(state.r30); 
+
+	GC_push_one(state.r0);
+	GC_push_one(state.r2);
+	GC_push_one(state.r3);
+	GC_push_one(state.r4);
+	GC_push_one(state.r5);
+	GC_push_one(state.r6);
+	GC_push_one(state.r7);
+	GC_push_one(state.r8);
+	GC_push_one(state.r9);
+	GC_push_one(state.r10);
+	GC_push_one(state.r11);
+	GC_push_one(state.r12);
+	GC_push_one(state.r13);
+	GC_push_one(state.r14);
+	GC_push_one(state.r15);
+	GC_push_one(state.r16);
+	GC_push_one(state.r17);
+	GC_push_one(state.r18);
+	GC_push_one(state.r19);
+	GC_push_one(state.r20);
+	GC_push_one(state.r21);
+	GC_push_one(state.r22);
+	GC_push_one(state.r23);
+	GC_push_one(state.r24);
+	GC_push_one(state.r25);
+	GC_push_one(state.r26);
+	GC_push_one(state.r27);
+	GC_push_one(state.r28);
+	GC_push_one(state.r29);
+	GC_push_one(state.r30);
 	GC_push_one(state.r31);
 #else
 # error FIXME for non-x86 || ppc architectures
@@ -177,7 +200,7 @@
 
     me = mach_thread_self();
     if (!GC_thr_initialized) GC_thr_init();
-    
+
     r = task_threads(current_task(), &act_list, &listcount);
     if(r != KERN_SUCCESS) ABORT("task_threads failed");
     for(i = 0; i < listcount; i++) {
@@ -200,36 +223,36 @@
 	lo = (void*)(info.r1 - PPC_RED_ZONE_SIZE);
 	hi = (ptr_t)FindTopOfStack(info.r1);
 
-	GC_push_one(info.r0); 
-	GC_push_one(info.r2); 
-	GC_push_one(info.r3); 
-	GC_push_one(info.r4); 
-	GC_push_one(info.r5); 
-	GC_push_one(info.r6); 
-	GC_push_one(info.r7); 
-	GC_push_one(info.r8); 
-	GC_push_one(info.r9); 
-	GC_push_one(info.r10); 
-	GC_push_one(info.r11); 
-	GC_push_one(info.r12); 
-	GC_push_one(info.r13); 
-	GC_push_one(info.r14); 
-	GC_push_one(info.r15); 
-	GC_push_one(info.r16); 
-	GC_push_one(info.r17); 
-	GC_push_one(info.r18); 
-	GC_push_one(info.r19); 
-	GC_push_one(info.r20); 
-	GC_push_one(info.r21); 
-	GC_push_one(info.r22); 
-	GC_push_one(info.r23); 
-	GC_push_one(info.r24); 
-	GC_push_one(info.r25); 
-	GC_push_one(info.r26); 
-	GC_push_one(info.r27); 
-	GC_push_one(info.r28); 
-	GC_push_one(info.r29); 
-	GC_push_one(info.r30); 
+	GC_push_one(info.r0);
+	GC_push_one(info.r2);
+	GC_push_one(info.r3);
+	GC_push_one(info.r4);
+	GC_push_one(info.r5);
+	GC_push_one(info.r6);
+	GC_push_one(info.r7);
+	GC_push_one(info.r8);
+	GC_push_one(info.r9);
+	GC_push_one(info.r10);
+	GC_push_one(info.r11);
+	GC_push_one(info.r12);
+	GC_push_one(info.r13);
+	GC_push_one(info.r14);
+	GC_push_one(info.r15);
+	GC_push_one(info.r16);
+	GC_push_one(info.r17);
+	GC_push_one(info.r18);
+	GC_push_one(info.r19);
+	GC_push_one(info.r20);
+	GC_push_one(info.r21);
+	GC_push_one(info.r22);
+	GC_push_one(info.r23);
+	GC_push_one(info.r24);
+	GC_push_one(info.r25);
+	GC_push_one(info.r26);
+	GC_push_one(info.r27);
+	GC_push_one(info.r28);
+	GC_push_one(info.r29);
+	GC_push_one(info.r30);
 	GC_push_one(info.r31);
 #      else
 	/* FIXME: Remove after testing:	*/
@@ -243,21 +266,21 @@
 	lo = (void*)info.esp;
 	hi = (ptr_t)FindTopOfStack(info.esp);
 
-	GC_push_one(info.eax); 
-	GC_push_one(info.ebx); 
-	GC_push_one(info.ecx); 
-	GC_push_one(info.edx); 
-	GC_push_one(info.edi); 
-	GC_push_one(info.esi); 
+	GC_push_one(info.eax);
+	GC_push_one(info.ebx);
+	GC_push_one(info.ecx);
+	GC_push_one(info.edx);
+	GC_push_one(info.edi);
+	GC_push_one(info.esi);
 	/* GC_push_one(info.ebp);  */
 	/* GC_push_one(info.esp);  */
-	GC_push_one(info.ss); 
-	GC_push_one(info.eip); 
-	GC_push_one(info.cs); 
-	GC_push_one(info.ds); 
-	GC_push_one(info.es); 
-	GC_push_one(info.fs); 
-	GC_push_one(info.gs); 
+	GC_push_one(info.ss);
+	GC_push_one(info.eip);
+	GC_push_one(info.cs);
+	GC_push_one(info.ds);
+	GC_push_one(info.es);
+	GC_push_one(info.fs);
+	GC_push_one(info.gs);
 #      endif /* !POWERPC */
       }
 #     if DEBUG_THREADS
@@ -267,7 +290,7 @@
 		  (unsigned long) hi
 		 );
 #     endif
-      GC_push_all_stack(lo, hi); 
+      GC_push_all_stack(lo, hi);
     } /* for(p=GC_threads[i]...) */
     vm_deallocate(current_task(), (vm_address_t)act_list, sizeof(thread_t) * listcount);
 }
@@ -290,7 +313,7 @@
 }
 
 /* returns true if there's a thread in act_list that wasn't in old_list */
-int GC_suspend_thread_list(thread_act_array_t act_list, int count, 
+int GC_suspend_thread_list(thread_act_array_t act_list, int count,
 			   thread_act_array_t old_list, int old_count) {
   mach_port_t my_thread = mach_thread_self();
   int i, j;
@@ -299,7 +322,7 @@
 
   for(i = 0; i < count; i++) {
     thread_act_t thread = act_list[i];
-#   if DEBUG_THREADS 
+#   if DEBUG_THREADS
       GC_printf1("Attempting to suspend thread %p\n", thread);
 #   endif
     /* find the current thread in the old list */
@@ -317,7 +340,7 @@
       /* default is not suspended */
       GC_mach_threads[GC_mach_threads_count].already_suspended = 0;
       changed = 1;
-    }      
+    }
 
     if (thread != my_thread &&
 	(!GC_use_mach_handler_thread
@@ -328,7 +351,7 @@
       kern_return_t kern_result = thread_info(thread, THREAD_BASIC_INFO,
 				(thread_info_t)&info, &outCount);
       if(kern_result != KERN_SUCCESS) {
-	/* the thread may have quit since the thread_threads () call 
+	/* the thread may have quit since the thread_threads () call
 	 * we mark already_suspended so it's not dealt with anymore later
 	 */
         if (!found) {
@@ -344,14 +367,14 @@
 	GC_mach_threads[GC_mach_threads_count].already_suspended = info.suspend_count;
       }
       if (info.suspend_count) continue;
-      
+
 #     if DEBUG_THREADS
         GC_printf1("Suspending 0x%lx\n", thread);
 #     endif
       /* Suspend the thread */
       kern_result = thread_suspend(thread);
       if(kern_result != KERN_SUCCESS) {
-	/* the thread may have quit since the thread_threads () call 
+	/* the thread may have quit since the thread_threads () call
 	 * we mark already_suspended so it's not dealt with anymore later
 	 */
         if (!found) {
@@ -360,7 +383,7 @@
 	}
 	continue;
       }
-    } 
+    }
     if (!found) GC_mach_threads_count++;
   }
   return changed;
@@ -376,14 +399,14 @@
     kern_return_t kern_result;
     thread_act_array_t act_list, prev_list;
     mach_msg_type_number_t listcount, prevcount;
-    
+
 #   if DEBUG_THREADS
       GC_printf1("Stopping the world from 0x%lx\n", mach_thread_self());
 #   endif
 
     /* clear out the mach threads list table */
-    GC_stop_init(); 
-       
+    GC_stop_init();
+
     /* Make sure all free list construction has stopped before we start. */
     /* No new construction can start, since free list construction is	*/
     /* required to acquire and release the GC lock before it starts,	*/
@@ -401,7 +424,7 @@
 	 thread, recognise it is stopped, but then have a new thread
 	 it created before stopping show up later.
       */
-      
+
       changes = 1;
       prev_list = NULL;
       prevcount = 0;
@@ -415,15 +438,15 @@
 	prevcount = listcount;
         vm_deallocate(current_task(), (vm_address_t)act_list, sizeof(thread_t) * listcount);
       } while (changes);
-      
- 
+
+
 #   ifdef MPROTECT_VDB
       if(GC_incremental) {
         extern void GC_mprotect_stop();
         GC_mprotect_stop();
       }
 #   endif
-    
+
 #   ifdef PARALLEL_MARK
       GC_release_mark_lock();
 #   endif
@@ -444,7 +467,7 @@
   mach_msg_type_number_t listcount;
   struct thread_basic_info info;
   mach_msg_type_number_t outCount = THREAD_INFO_MAX;
-  
+
 #   if DEBUG_THREADS
       GC_printf0("World starting\n");
 #   endif
@@ -481,7 +504,7 @@
 	    /* Resume the thread */
 	    kern_result = thread_resume(thread);
 	    if(kern_result != KERN_SUCCESS) ABORT("thread_resume failed");
-	  } 
+	  }
 	}
       }
     }
Index: external/gc6.7/include/private/gc_priv.h
===================================================================
--- external/gc6.7/include/private/gc_priv.h	(revision 6634)
+++ external/gc6.7/include/private/gc_priv.h	(working copy)
@@ -1,4 +1,4 @@
-/* 
+/*
  * Copyright 1988, 1989 Hans-J. Boehm, Alan J. Demers
  * Copyright (c) 1991-1994 by Xerox Corporation.  All rights reserved.
  * Copyright (c) 1996-1999 by Silicon Graphics.  All rights reserved.
@@ -14,8 +14,8 @@
  * provided the above notices are retained, and a notice that the code was
  * modified is included with the above copyright notice.
  */
- 
 
+
 # ifndef GC_PRIVATE_H
 # define GC_PRIVATE_H
 
@@ -61,7 +61,7 @@
 			/* byte displacements.				*/
 			/* Preferably identical to caddr_t, if it 	*/
 			/* exists.					*/
-			
+
 # ifndef GCCONFIG_H
 #   include "gcconfig.h"
 # endif
@@ -158,7 +158,7 @@
 		    /* If not, try to keep individual objects small.	*/
 		    /* This is now really controlled at startup,	*/
 		    /* through GC_all_interior_pointers.		*/
-		    
+
 #define PRINTSTATS  /* Print garbage collection statistics          	*/
 		    /* For less verbose output, undefine in reclaim.c 	*/
 
@@ -276,7 +276,7 @@
 /* Fill in the pc and argument information for up to NFRAMES of my	*/
 /* callers.  Ignore my frame and my callers frame.			*/
 void GC_save_callers GC_PROTO((struct callinfo info[NFRAMES]));
-  
+
 void GC_print_callers GC_PROTO((struct callinfo info[NFRAMES]));
 
 #endif
@@ -383,7 +383,7 @@
 # else
 #   if defined(THREADS) || defined(AMIGA)  \
 	|| defined(MSWIN32) || defined(MSWINCE) || defined(MACOS) \
-	|| defined(DJGPP) || defined(NO_SIGNALS) 
+	|| defined(DJGPP) || defined(NO_SIGNALS)
 			/* Also useful for debugging.		*/
 	/* Should probably use thr_sigsetmask for GC_SOLARIS_THREADS. */
 #     define DISABLE_SIGNALS()
@@ -464,6 +464,60 @@
 #   define GETENV(name) 0
 #endif
 
+
+#if defined(DARWIN)
+# if defined(POWERPC)
+#   if CPP_WORDSZ == 32
+#     define GC_THREAD_STATE_T          ppc_thread_state_t
+#     define GC_MACH_THREAD_STATE       PPC_THREAD_STATE
+#     define GC_MACH_THREAD_STATE_COUNT PPC_THREAD_STATE_COUNT
+#   else
+#     define GC_THREAD_STATE_T          ppc_thread_state64_t
+#     define GC_MACH_THREAD_STATE       PPC_THREAD_STATE64
+#     define GC_MACH_THREAD_STATE_COUNT PPC_THREAD_STATE64_COUNT
+#   endif
+# elif defined(I386) || defined(X86_64)
+#   if CPP_WORDSZ == 32
+#     define GC_THREAD_STATE_T          x86_thread_state32_t
+#     define GC_MACH_THREAD_STATE       x86_THREAD_STATE32
+#     define GC_MACH_THREAD_STATE_COUNT x86_THREAD_STATE32_COUNT
+#   else
+#     define GC_THREAD_STATE_T          x86_thread_state64_t
+#     define GC_MACH_THREAD_STATE       x86_THREAD_STATE64
+#     define GC_MACH_THREAD_STATE_COUNT x86_THREAD_STATE64_COUNT
+#   endif
+# else
+#   if defined(ARM32)
+#     define GC_THREAD_STATE_T          arm_thread_state_t
+#   else
+#     error define GC_THREAD_STATE_T
+#   endif
+#   define GC_MACH_THREAD_STATE         MACHINE_THREAD_STATE
+#   define GC_MACH_THREAD_STATE_COUNT   MACHINE_THREAD_STATE_COUNT
+# endif
+
+# if CPP_WORDSZ == 32
+#   define GC_MACH_HEADER   mach_header
+#   define GC_MACH_SECTION  section
+#   define GC_GETSECTBYNAME getsectbynamefromheader
+# else
+#   define GC_MACH_HEADER   mach_header_64
+#   define GC_MACH_SECTION  section_64
+#   define GC_GETSECTBYNAME getsectbynamefromheader_64
+# endif
+
+  /* Try to work out the right way to access thread state structure     */
+  /* members.  The structure has changed its definition in different    */
+  /* Darwin versions.  This now defaults to the (older) names           */
+  /* without __, thus hopefully, not breaking any existing              */
+  /* Makefile.direct builds.                                            */
+# if __DARWIN_UNIX03
+#   define THREAD_FLD(x) __ ## x
+# else
+#   define THREAD_FLD(x) x
+# endif
+#endif /* DARWIN */
+
 /*********************************/
 /*                               */
 /* Word-size-dependent defines   */
@@ -551,7 +605,7 @@
 #define MAXOBJBYTES ((word)CPP_MAXOBJBYTES)
 #define CPP_MAXOBJSZ    BYTES_TO_WORDS(CPP_MAXOBJBYTES)
 #define MAXOBJSZ ((word)CPP_MAXOBJSZ)
-		
+
 # define divHBLKSZ(n) ((n) >> LOG_HBLKSIZE)
 
 # define HBLK_PTR_DIFF(p,q) divHBLKSZ((ptr_t)p - (ptr_t)q)
@@ -561,9 +615,9 @@
 	/* instead of a shift.  The bundled SunOS 4.1	*/
 	/* o.w. sometimes pessimizes the subtraction to	*/
 	/* involve a call to .div.			*/
- 
+
 # define modHBLKSZ(n) ((n) & (HBLKSIZE-1))
- 
+
 # define HBLKPTR(objptr) ((struct hblk *)(((word) (objptr)) & ~(HBLKSIZE-1)))
 
 # define HBLKDISPL(objptr) (((word) (objptr)) & (HBLKSIZE-1))
@@ -599,7 +653,7 @@
  * OK to add spurious entries to sets.
  * Used by black-listing code, and perhaps by dirty bit maintenance code.
  */
- 
+
 # ifdef LARGE_CONFIG
 #   define LOG_PHT_ENTRIES  20  /* Collisions likely at 1M blocks,	*/
 				/* which is >= 4GB.  Each table takes	*/
@@ -636,9 +690,9 @@
 /* This sets (many) extra bits.						*/
 # define set_pht_entry_from_index_safe(bl, index) \
 		(bl)[divWORDSZ(index)] = ONES
-	
 
 
+
 /********************************************/
 /*                                          */
 /*    H e a p   B l o c k s                 */
@@ -680,7 +734,7 @@
     struct hblk * hb_prev;	/* Backwards link for free list.	*/
     word hb_descr;   		/* object descriptor for marking.  See	*/
     				/* mark.h.				*/
-    map_entry_type * hb_map;	
+    map_entry_type * hb_map;
     			/* A pointer to a pointer validity map of the block. */
     		      	/* See GC_obj_map.				     */
     		     	/* Valid for all blocks with headers.		     */
@@ -756,7 +810,7 @@
 #   define MAX_ROOT_SETS 4096
 # else
     /* GCJ LOCAL: MAX_ROOT_SETS increased to permit more shared */
-    /* libraries to be loaded.                                  */ 
+    /* libraries to be loaded.                                  */
 #   define MAX_ROOT_SETS 1024
 # endif
 
@@ -894,7 +948,7 @@
     unsigned _size_map[WORDS_TO_BYTES(MAXOBJSZ+1)];
     	/* Number of words to allocate for a given allocation request in */
     	/* bytes.							 */
-# endif 
+# endif
 
 # ifdef STUBBORN_ALLOC
     ptr_t _sobjfreelist[MAXOBJSZ+1];
@@ -919,7 +973,7 @@
 #   define MAP_ENTRY(map, bytes) (map)[bytes]
 #   define MAP_ENTRIES HBLKSIZE
 #   define MAP_SIZE MAP_ENTRIES
-#   define CPP_MAX_OFFSET (OFFSET_TOO_BIG - 1)	
+#   define CPP_MAX_OFFSET (OFFSET_TOO_BIG - 1)
 #   define MAX_OFFSET ((word)CPP_MAX_OFFSET)
     /* The following are used only if GC_all_interior_ptrs != 0 */
 # 	define VALID_OFFSET_SZ \
@@ -947,7 +1001,7 @@
 				     /* GC_read_dirty.			   */
 # endif
 # ifdef MPROTECT_VDB
-    VOLATILE page_hash_table _dirty_pages;	
+    VOLATILE page_hash_table _dirty_pages;
 			/* Pages dirtied since last GC_read_dirty. */
 # endif
 # ifdef PROC_VDB
@@ -995,7 +1049,7 @@
 #endif
 };
 
-GC_API GC_FAR struct _GC_arrays GC_arrays; 
+GC_API GC_FAR struct _GC_arrays GC_arrays;
 
 # ifndef SEPARATE_GLOBALS
 #   define GC_objfreelist GC_arrays._objfreelist
@@ -1180,7 +1234,7 @@
 
 extern word GC_root_size;	/* Total size of registered root sections */
 
-extern GC_bool GC_debugging_started;	/* GC_debug_malloc has been called. */ 
+extern GC_bool GC_debugging_started;	/* GC_debug_malloc has been called. */
 
 extern long GC_large_alloc_warn_interval;
 	/* Interval between unsuppressed warnings.	*/
@@ -1258,9 +1312,9 @@
 /* Important internal collector routines */
 
 ptr_t GC_approx_sp GC_PROTO((void));
-  
+
 GC_bool GC_should_collect GC_PROTO((void));
-  
+
 void GC_apply_to_all_blocks GC_PROTO(( \
     void (*fn) GC_PROTO((struct hblk *h, word client_data)), \
     word client_data));
@@ -1436,7 +1490,7 @@
 		/* We need to register the main data segment.  Returns	*/
 		/* TRUE unless this is done implicitly as part of	*/
 		/* dynamic library registration.			*/
-  
+
 /* Machine dependent startup routines */
 ptr_t GC_get_stack_base GC_PROTO((void));	/* Cold end of stack */
 #ifdef IA64
@@ -1444,7 +1498,7 @@
   					/* Cold end of register stack.	*/
 #endif
 void GC_register_data_segments GC_PROTO((void));
-  
+
 /* Black listing: */
 void GC_bl_init GC_PROTO((void));
 # ifdef PRINT_BLACK_LIST
@@ -1489,13 +1543,13 @@
   			/* Return the number of (stack) blacklisted	*/
   			/* blocks in the range for statistical		*/
   			/* purposes.					*/
-  		 	
+
 ptr_t GC_scratch_alloc GC_PROTO((word bytes));
   				/* GC internal memory allocation for	*/
   				/* small objects.  Deallocation is not  */
   				/* possible.				*/
-  	
-/* Heap block layout maps: */			
+
+/* Heap block layout maps: */
 void GC_invalidate_map GC_PROTO((hdr * hhdr));
   				/* Remove the object map associated	*/
   				/* with the block.  This identifies	*/
@@ -1509,11 +1563,11 @@
   				/* Version of GC_register_displacement	*/
   				/* that assumes lock is already held	*/
   				/* and signals are already disabled.	*/
-  
-/*  hblk allocation: */		
+
+/*  hblk allocation: */
 void GC_new_hblk GC_PROTO((word size_in_words, int kind));
   				/* Allocate a new heap block, and build */
-  				/* a free list in it.			*/				
+  				/* a free list in it.			*/
 
 ptr_t GC_build_fl GC_PROTO((struct hblk *h, word sz,
 			   GC_bool clear,  ptr_t list));
@@ -1547,7 +1601,7 @@
 void GC_freehblk GC_PROTO((struct hblk * p));
 				/* Deallocate a heap block and mark it  */
   				/* as invalid.				*/
-  				
+
 /*  Misc GC: */
 void GC_init_inner GC_PROTO((void));
 GC_bool GC_expand_hp_inner GC_PROTO((word n));
@@ -1643,7 +1697,7 @@
   				/* head.				*/
 
 void GC_free_inner(GC_PTR p);
-  
+
 void GC_init_headers GC_PROTO((void));
 struct hblkhdr * GC_install_header GC_PROTO((struct hblk *h));
   				/* Install a header for block h.	*/
@@ -1658,7 +1712,7 @@
 void GC_remove_counts GC_PROTO((struct hblk * h, word sz));
   				/* Remove forwarding counts for h.	*/
 hdr * GC_find_header GC_PROTO((ptr_t h)); /* Debugging only.		*/
-  
+
 void GC_finalize GC_PROTO((void));
  			/* Perform all indicated finalization actions	*/
   			/* on unmarked objects.				*/
@@ -1678,10 +1732,10 @@
 			/* Auxiliary fns to make finalization work	*/
 			/* correctly with displaced pointers introduced	*/
 			/* by the debugging allocators.			*/
-  			
+
 void GC_add_to_heap GC_PROTO((struct hblk *p, word bytes));
   			/* Add a HBLKSIZE aligned chunk to the heap.	*/
-  
+
 void GC_print_obj GC_PROTO((ptr_t p));
   			/* P points to somewhere inside an object with	*/
   			/* debugging info.  Print a human readable	*/
@@ -1779,14 +1833,14 @@
   			/* h is about to be writteni or allocated.  Ensure  */
 			/* that it's not write protected by the virtual	    */
 			/* dirty bit implementation.			    */
-			
+
 void GC_dirty_init GC_PROTO((void));
-  
+
 /* Slow/general mark bit manipulation: */
 GC_API GC_bool GC_is_marked GC_PROTO((ptr_t p));
 void GC_clear_mark_bit GC_PROTO((ptr_t p));
 void GC_set_mark_bit GC_PROTO((ptr_t p));
-  
+
 /* Stubborn objects: */
 void GC_read_changed GC_PROTO((void));	/* Analogous to GC_read_dirty */
 GC_bool GC_page_was_changed GC_PROTO((struct hblk * h));
@@ -1794,7 +1848,7 @@
 void GC_clean_changing_list GC_PROTO((void));
  				/* Collect obsolete changing list entries */
 void GC_stubborn_init GC_PROTO((void));
-  
+
 /* Debugging print routines: */
 void GC_print_block_list GC_PROTO((void));
 void GC_print_hblkfreelist GC_PROTO((void));
@@ -1809,7 +1863,7 @@
 #  define GC_STORE_BACK_PTR(source, dest) GC_store_back_pointer(source, dest)
 #  define GC_MARKED_FOR_FINALIZATION(dest) GC_marked_for_finalization(dest)
 #else
-#  define GC_STORE_BACK_PTR(source, dest) 
+#  define GC_STORE_BACK_PTR(source, dest)
 #  define GC_MARKED_FOR_FINALIZATION(dest)
 #endif
 
@@ -1861,7 +1915,7 @@
 							(long)c, (long)d, \
 							(long)e, (long)g)
 			/* Ditto, writes to stderr.			*/
-			
+
 void GC_err_puts GC_PROTO((GC_CONST char *s));
 			/* Write s to stderr, don't buffer, don't add	*/
 			/* newlines, don't ...				*/
@@ -1878,14 +1932,14 @@
 		GC_err_printf2("Assertion failure: %s:%ld\n", \
 				__FILE__, (unsigned long)__LINE__); \
 		ABORT("assertion failure"); }
-# else 
+# else
 #	define GC_ASSERT(expr)
 # endif
 
 /* Check a compile time assertion at compile time.  The error	*/
 /* message for failure is a bit baroque, but ...		*/
 #if defined(mips) && !defined(__GNUC__)
-/* DOB: MIPSPro C gets an internal error taking the sizeof an array type. 
+/* DOB: MIPSPro C gets an internal error taking the sizeof an array type.
    This code works correctly (ugliness is to avoid "unused var" warnings) */
 # define GC_STATIC_ASSERT(expr) do { if (0) { char j[(expr)? 1 : -1]; j[0]='\0'; j[0]=j[0]; } } while(0)
 #else
@@ -1902,7 +1956,7 @@
     /* acquired, the GC lock must be acquired first.  The mark lock is	*/
     /* used to both protect some variables used by the parallel		*/
     /* marker, and to protect GC_fl_builder_count, below.		*/
-    /* GC_notify_all_marker() is called when				*/ 
+    /* GC_notify_all_marker() is called when				*/
     /* the state of the parallel marker changes				*/
     /* in some significant way (see gc_mark.h for details).  The	*/
     /* latter set of events includes incrementing GC_mark_no.		*/
@@ -1951,10 +2005,10 @@
 #       define SIG_SUSPEND _SIGRTMIN + 6
 #     else
 #       define SIG_SUSPEND SIGRTMIN + 6
-#     endif       
+#     endif
 #   endif
 #  endif /* !SIG_SUSPEND */
-  
+
 # endif
 
 # endif /* GC_PRIVATE_H */
Index: external/gc6.7/include/private/gcconfig.h
===================================================================
--- external/gc6.7/include/private/gcconfig.h	(revision 6634)
+++ external/gc6.7/include/private/gcconfig.h	(working copy)
@@ -1,4 +1,4 @@
-/* 
+/*
  * Copyright 1988, 1989 Hans-J. Boehm, Alan J. Demers
  * Copyright (c) 1991-1994 by Xerox Corporation.  All rights reserved.
  * Copyright (c) 1996 by Silicon Graphics.  All rights reserved.
@@ -21,19 +21,18 @@
  * case, a few declarations relying on types declared in gc_priv.h will be
  * omitted.
  */
- 
+
 #ifndef GCCONFIG_H
+#define GCCONFIG_H
 
-# define GCCONFIG_H
-
 # ifndef GC_PRIVATE_H
-    /* Fake ptr_t declaration, just to avoid compilation errors.	*/
-    /* This avoids many instances if "ifndef GC_PRIVATE_H" below.	*/
+    /* Fake ptr_t declaration, just to avoid compilation errors.        */
+    /* This avoids many instances if "ifndef GC_PRIVATE_H" below.       */
     typedef struct GC_undefined_struct * ptr_t;
 # endif
 
-/* Machine dependent parameters.  Some tuning parameters can be found	*/
-/* near the top of gc_private.h.					*/
+/* Machine dependent parameters.  Some tuning parameters can be found   */
+/* near the top of gc_private.h.                                        */
 
 /* Machine specific parts contributed by various people.  See README file. */
 
@@ -59,6 +58,11 @@
 #    define FREEBSD
 # endif
 
+/* And one for Darwin: */
+# if defined(macosx) || (defined(__APPLE__) && defined(__MACH__))
+#   define DARWIN
+# endif
+
 /* Determine the machine type: */
 # if defined(__arm__) || defined(__thumb__)
 #    define ARM32
@@ -283,7 +287,7 @@
 # if defined(_AMIGA) && !defined(AMIGA)
 #   define AMIGA
 # endif
-# ifdef AMIGA 
+# ifdef AMIGA
 #   define M68K
 #   define mach_type_known
 # endif
@@ -297,15 +301,24 @@
 #   define MACOS
 #   define mach_type_known
 # endif
-# if defined(macosx) || (defined(__APPLE__) && defined(__MACH__))
+# if defined(macosx) || (defined(__APPLE__) && defined(__MACH__)) || defined(MAC_OS)
 #   define DARWIN
+#	define DATASTART ((ptr_t) get_etext())
+#   define DATAEND	/* not needed */
+#   define STACKBOTTOM ((ptr_t) LMGetCurStackBase())
 #   if defined(__ppc__)  || defined(__ppc64__)
 #    define POWERPC
 #    define mach_type_known
-#   endif
-#   if defined(__i386__)
+#   elif defined(__x86_64__) || defined(__x86_64)
+#    define X86_64
+#    define mach_type_known
+#   elif defined(__i386__)
 #    define I386
 #    define mach_type_known
+#   elif defined(__arm__)
+#    define ARM32
+#    define mach_type_known
+#    define DARWIN_DONT_PARSE_STACK
 #   endif
 # endif
 # if defined(NeXT) && defined(mc68000)
@@ -338,7 +351,7 @@
 # if defined(FREEBSD) && defined(__sparc__)
 #    define SPARC
 #    define mach_type_known
-#endif
+# endif
 # if defined(bsdi) && (defined(i386) || defined(__i386__))
 #    define I386
 #    define BSDI
@@ -443,11 +456,11 @@
 # endif
 # if defined(__GNU__)
 #   if defined(__i386__)
-/* The Debian Hurd running on generic PC */  
+/* The Debian Hurd running on generic PC */
 #     define  HURD
 #     define  I386
 #     define  mach_type_known
-#    endif 
+#    endif
 # endif
 # if defined(__TANDEM)
     /* Nonstop S-series */
@@ -795,38 +808,40 @@
 #     define DATAEND (_end)
 #   endif
 #   ifdef DARWIN
-#     ifdef __ppc64__
+#     define OS_TYPE "DARWIN"
+#     define DYNAMIC_LOADING
+#     if defined(__ppc64__)
 #       define ALIGNMENT 8
 #       define CPP_WORDSZ 64
+#       define STACKBOTTOM ((ptr_t) 0x7fff5fc00000)
+#       define CACHE_LINE_SIZE 64
+#       ifndef HBLKSIZE
+#         define HBLKSIZE 4096
+#       endif
 #     else
 #       define ALIGNMENT 4
+#       define STACKBOTTOM ((ptr_t) 0xc0000000)
 #     endif
-#     define OS_TYPE "DARWIN"
-#     define DYNAMIC_LOADING
-      /* XXX: see get_end(3), get_etext() and get_end() should not be used.
-         These aren't used when dyld support is enabled (it is by default) */
+      /* XXX: see get_end(3), get_etext() and get_end() should not be used. */
+      /* These aren't used when dyld support is enabled (it is by default). */
 #     define DATASTART ((ptr_t) get_etext())
-#     define DATAEND	((ptr_t) get_end())
-#     define STACKBOTTOM ((ptr_t) 0xc0000000)
-#     define USE_MMAP
+#     define DATAEND   ((ptr_t) get_end())
+#     ifndef USE_MMAP
+#       define USE_MMAP
+#     endif
 #     define USE_MMAP_ANON
-#     define USE_ASM_PUSH_REGS
-      /* This is potentially buggy. It needs more testing. See the comments in
-         os_dep.c.  It relies on threads to track writes. */
-#     ifdef GC_DARWIN_THREADS
-/* #       define MPROTECT_VDB -- diabled for now.  May work for some apps. */
-#     endif
+#     define MPROTECT_VDB
 #     include <unistd.h>
 #     define GETPAGESIZE() getpagesize()
 #     if defined(USE_PPC_PREFETCH) && defined(__GNUC__)
-	/* The performance impact of prefetches is untested */
-#	define PREFETCH(x) \
-	  __asm__ __volatile__ ("dcbt 0,%0" : : "r" ((const void *) (x)))
-#	define PREFETCH_FOR_WRITE(x) \
-	  __asm__ __volatile__ ("dcbtst 0,%0" : : "r" ((const void *) (x)))
+        /* The performance impact of prefetches is untested */
+#       define PREFETCH(x) \
+          __asm__ __volatile__ ("dcbt 0,%0" : : "r" ((const void *) (x)))
+#       define PREFETCH_FOR_WRITE(x) \
+          __asm__ __volatile__ ("dcbtst 0,%0" : : "r" ((const void *) (x)))
 #     endif
-      /* There seems to be some issues with trylock hanging on darwin. This
-         should be looked into some more */
+      /* There seems to be some issues with trylock hanging on darwin.  */
+      /* This should be looked into some more.                          */
 #     define NO_PTHREAD_TRYLOCK
 #   endif
 #   ifdef FREEBSD
@@ -1045,7 +1060,7 @@
 #	define OS_TYPE "SEQUENT"
 	extern int etext[];
 #       define DATASTART ((ptr_t)((((word) (etext)) + 0xfff) & ~0xfff))
-#       define STACKBOTTOM ((ptr_t) 0x3ffff000) 
+#       define STACKBOTTOM ((ptr_t) 0x3ffff000)
 #   endif
 #   ifdef BEOS
 #     define OS_TYPE "BEOS"
@@ -1186,7 +1201,7 @@
 	    /* cache miss stalls for the targetted load instructions.  But it	*/
 	    /* seems to interfere enough with other cache traffic that the net	*/
 	    /* result is worse than prefetchnta.				*/
-#         if 0 
+#         if 0
 	    /* Using prefetches for write seems to have a slight negative	*/
 	    /* impact on performance, at least for a PIII/500.			*/
 #	    define PREFETCH_FOR_WRITE(x) \
@@ -1313,24 +1328,21 @@
 #     define OS_TYPE "DARWIN"
 #     define DARWIN_DONT_PARSE_STACK
 #     define DYNAMIC_LOADING
-      /* XXX: see get_end(3), get_etext() and get_end() should not be used.
-        These aren't used when dyld support is enabled (it is by default) */
+      /* XXX: see get_end(3), get_etext() and get_end() should not be used. */
+      /* These aren't used when dyld support is enabled (it is by default). */
 #     define DATASTART ((ptr_t) get_etext())
-#     define DATAEND	((ptr_t) get_end())
+#     define DATAEND   ((ptr_t) get_end())
 #     define STACKBOTTOM ((ptr_t) 0xc0000000)
-#     define USE_MMAP
+#     ifndef USE_MMAP
+#       define USE_MMAP
+#     endif
 #     define USE_MMAP_ANON
-#     define USE_ASM_PUSH_REGS
-      /* This is potentially buggy. It needs more testing. See the comments in
-        os_dep.c.  It relies on threads to track writes. */
-#     ifdef GC_DARWIN_THREADS
-/* #       define MPROTECT_VDB -- disabled for now.  May work for some apps. */
-#     endif
+#     define MPROTECT_VDB
 #     include <unistd.h>
 #     define GETPAGESIZE() getpagesize()
-      /* There seems to be some issues with trylock hanging on darwin. This
-         should be looked into some more */
-#      define NO_PTHREAD_TRYLOCK
+      /* There seems to be some issues with trylock hanging on darwin.  */
+      /* This should be looked into some more.                          */
+#     define NO_PTHREAD_TRYLOCK
 #   endif /* DARWIN */
 # endif
 
@@ -1678,7 +1690,7 @@
 	    /* Requires 16 byte alignment for malloc */
 #         define ALIGNMENT 8
 #       endif
-#       define OS_TYPE "HPUX"	
+#       define OS_TYPE "HPUX"
         extern int __data_start[];
 #       define DATASTART ((ptr_t)(__data_start))
         /* Gustavo Rodriguez-Rivera suggested changing HEURISTIC2	*/
@@ -1930,7 +1942,7 @@
 #      define DYNAMIC_LOADING
 #   endif
 # endif
- 
+
 # ifdef SH4
 #   define MACH_TYPE "SH4"
 #   define OS_TYPE "MSWINCE"
@@ -1993,6 +2005,49 @@
 #	    define PREFETCH_FOR_WRITE(x) __builtin_prefetch((x), 1)
 #	endif
 #   endif
+#   ifdef DARWIN
+#     define OS_TYPE "DARWIN"
+#     define DARWIN_DONT_PARSE_STACK
+#     define DYNAMIC_LOADING
+      /* XXX: see get_end(3), get_etext() and get_end() should not be used. */
+      /* These aren't used when dyld support is enabled (it is by default)  */
+#     define DATASTART ((ptr_t) get_etext())
+#     define DATAEND   ((ptr_t) get_end())
+#     define STACKBOTTOM ((ptr_t) 0x7fff5fc00000)
+#     ifndef USE_MMAP
+#       define USE_MMAP
+#     endif
+#     define USE_MMAP_ANON
+#     define MPROTECT_VDB
+#     include <unistd.h>
+#     define GETPAGESIZE() getpagesize()
+      /* There seems to be some issues with trylock hanging on darwin.  */
+      /* This should be looked into some more.                          */
+#     define NO_PTHREAD_TRYLOCK
+#   endif
+#   ifdef FREEBSD
+#       define OS_TYPE "FREEBSD"
+#       ifndef GC_FREEBSD_THREADS
+#           define MPROTECT_VDB
+#       endif
+#       ifdef __GLIBC__
+#           define SIG_SUSPEND          (32+6)
+#           define SIG_THR_RESTART      (32+5)
+            extern int _end[];
+#           define DATAEND (ptr_t)(_end)
+#       else
+#           define SIG_SUSPEND SIGUSR1
+#           define SIG_THR_RESTART SIGUSR2
+#       endif
+#       define FREEBSD_STACKBOTTOM
+#       ifdef __ELF__
+#           define DYNAMIC_LOADING
+#       endif
+        extern char etext[];
+        ptr_t GC_FreeBSDGetDataStart(size_t, ptr_t);
+#       define DATASTART GC_FreeBSDGetDataStart(0x1000, (ptr_t)etext)
+#       define DATASTART_IS_FUNC
+#   endif
 #   ifdef NETBSD
 #	define OS_TYPE "NETBSD"
 #	ifdef __ELF__
@@ -2017,7 +2072,7 @@
     /* by rld's internal malloc.					*/
 #   define USE_PROC_FOR_LIBRARIES
 #endif
-    
+
 # ifndef STACK_GROWS_UP
 #   define STACK_GROWS_DOWN
 # endif
@@ -2224,7 +2279,7 @@
 
 # if defined(SAVE_CALL_COUNT) && !defined(GC_ADD_CALLER) \
 	     && defined(GC_CAN_SAVE_CALL_STACKS)
-#   define SAVE_CALL_CHAIN 
+#   define SAVE_CALL_CHAIN
 # endif
 # ifdef SAVE_CALL_CHAIN
 #   if defined(SAVE_CALL_NARGS) && defined(CAN_SAVE_CALL_ARGS)
Index: external/gc6.7/os_dep.c
===================================================================
--- external/gc6.7/os_dep.c	(revision 6634)
+++ external/gc6.7/os_dep.c	(working copy)
@@ -34,8 +34,8 @@
 #     include <features.h>
 #     if 2 <= __GLIBC__
 #       if 2 == __GLIBC__ && 0 == __GLIBC_MINOR__
-	  /* glibc 2.1 no longer has sigcontext.h.  But signal.h	*/
-	  /* has the right declaration for glibc 2.1.			*/
+    /* glibc 2.1 no longer has sigcontext.h.  But signal.h  */
+    /* has the right declaration for glibc 2.1.     */
 #         include <sigcontext.h>
 #       endif /* 0 == __GLIBC_MINOR__ */
 #     else /* not 2 <= __GLIBC__ */
@@ -49,7 +49,7 @@
     && !defined(MSWINCE)
 #   include <sys/types.h>
 #   if !defined(MSWIN32) && !defined(SUNOS4)
-#   	include <unistd.h>
+#     include <unistd.h>
 #   endif
 # endif
 
@@ -64,8 +64,8 @@
 # include <ctype.h>
 #endif
 
-/* Blatantly OS dependent routines, except for those that are related 	*/
-/* to dynamic loading.							*/
+/* Blatantly OS dependent routines, except for those that are related   */
+/* to dynamic loading.              */
 
 # if defined(HEURISTIC2) || defined(SEARCH_FOR_DATA_START)
 #   define NEED_FIND_LIMIT
@@ -93,7 +93,7 @@
 
 #if (defined(NETBSD) || defined(OPENBSD)) && defined(__ELF__) \
     && !defined(NEED_FIND_LIMIT)
-   /* Used by GC_init_netbsd_elf() below.	*/
+   /* Used by GC_init_netbsd_elf() below. */
 #  define NEED_FIND_LIMIT
 #endif
 
@@ -136,8 +136,8 @@
 # if defined(SUNOS5SIGS) && !defined(FREEBSD)
 #  include <sys/siginfo.h>
 # endif
-  /* Define SETJMP and friends to be the version that restores	*/
-  /* the signal mask.						*/
+  /* Define SETJMP and friends to be the version that restores  */
+  /* the signal mask.           */
 # define SETJMP(env) sigsetjmp(env, 1)
 # define LONGJMP(env, val) siglongjmp(env, val)
 # define JMP_BUF sigjmp_buf
@@ -153,8 +153,8 @@
 #endif
 
 #ifdef DJGPP
-  /* Apparently necessary for djgpp 2.01.  May cause problems with	*/
-  /* other versions.							*/
+  /* Apparently necessary for djgpp 2.01.  May cause problems with  */
+  /* other versions.              */
   typedef long unsigned int caddr_t;
 #endif
 
@@ -173,24 +173,24 @@
 #if defined(LINUX) && \
     (defined(USE_PROC_FOR_LIBRARIES) || defined(IA64) || !defined(SMALL_CONFIG))
 
-/* We need to parse /proc/self/maps, either to find dynamic libraries,	*/
-/* and/or to find the register backing store base (IA64).  Do it once	*/
-/* here.								*/
+/* We need to parse /proc/self/maps, either to find dynamic libraries,  */
+/* and/or to find the register backing store base (IA64).  Do it once */
+/* here.                */
 
 #define READ read
 
-/* Repeatedly perform a read call until the buffer is filled or	*/
-/* we encounter EOF.						*/
+/* Repeatedly perform a read call until the buffer is filled or */
+/* we encounter EOF.            */
 ssize_t GC_repeat_read(int fd, char *buf, size_t count)
 {
     ssize_t num_read = 0;
     ssize_t result;
-    
+
     while (num_read < count) {
-	result = READ(fd, buf + num_read, count - num_read);
-	if (result < 0) return result;
-	if (result == 0) break;
-	num_read += result;
+  result = READ(fd, buf + num_read, count - num_read);
+  if (result < 0) return result;
+  if (result == 0) break;
+  num_read += result;
     }
     return num_read;
 }
@@ -207,35 +207,35 @@
 {
     int f;
     int result;
-    size_t maps_size = 4000;  /* Initial guess. 	*/
+    size_t maps_size = 4000;  /* Initial guess.   */
     static char init_buf[1];
     static char *maps_buf = init_buf;
     static size_t maps_buf_sz = 1;
 
-    /* Read /proc/self/maps, growing maps_buf as necessary.	*/
-        /* Note that we may not allocate conventionally, and	*/
-        /* thus can't use stdio.				*/
-	do {
-	    if (maps_size >= maps_buf_sz) {
-	      /* Grow only by powers of 2, since we leak "too small" buffers. */
-	      while (maps_size >= maps_buf_sz) maps_buf_sz *= 2;
-	      maps_buf = GC_scratch_alloc(maps_buf_sz);
-	      if (maps_buf == 0) return 0;
-	    }
-	    f = open("/proc/self/maps", O_RDONLY);
-	    if (-1 == f) return 0;
-	    maps_size = 0;
-	    do {
-	        result = GC_repeat_read(f, maps_buf, maps_buf_sz-1);
-	        if (result <= 0) return 0;
-	        maps_size += result;
-	    } while (result == maps_buf_sz-1);
-	    close(f);
-	} while (maps_size >= maps_buf_sz);
+    /* Read /proc/self/maps, growing maps_buf as necessary. */
+        /* Note that we may not allocate conventionally, and  */
+        /* thus can't use stdio.        */
+  do {
+      if (maps_size >= maps_buf_sz) {
+        /* Grow only by powers of 2, since we leak "too small" buffers. */
+        while (maps_size >= maps_buf_sz) maps_buf_sz *= 2;
+        maps_buf = GC_scratch_alloc(maps_buf_sz);
+        if (maps_buf == 0) return 0;
+      }
+      f = open("/proc/self/maps", O_RDONLY);
+      if (-1 == f) return 0;
+      maps_size = 0;
+      do {
+          result = GC_repeat_read(f, maps_buf, maps_buf_sz-1);
+          if (result <= 0) return 0;
+          maps_size += result;
+      } while (result == maps_buf_sz-1);
+      close(f);
+  } while (maps_size >= maps_buf_sz);
         maps_buf[maps_size] = '\0';
-	
+
     /* Apply fn to result. */
-	return fn(maps_buf);
+  return fn(maps_buf);
 }
 
 #endif /* Need GC_apply_to_maps */
@@ -289,12 +289,12 @@
     memcpy(prot_buf, prot_start, 4);
     prot_buf[4] = '\0';
     if (prot_buf[1] == 'w') {/* we can skip the rest if it's not writable. */
-	/* Skip past protection field to offset field */
+  /* Skip past protection field to offset field */
           while (!isspace(*p)) ++p; while (isspace(*p)) ++p;
           GC_ASSERT(isxdigit(*p));
-	/* Skip past offset field, which we ignore */
+  /* Skip past offset field, which we ignore */
           while (!isspace(*p)) ++p; while (isspace(*p)) ++p;
-	maj_dev_start = p;
+  maj_dev_start = p;
         GC_ASSERT(isxdigit(*maj_dev_start));
         *maj_dev = strtoul(maj_dev_start, NULL, 16);
     }
@@ -304,20 +304,20 @@
     return p;
 }
 
-#endif /* Need to parse /proc/self/maps. */	
+#endif /* Need to parse /proc/self/maps. */
 
 #if defined(SEARCH_FOR_DATA_START)
-  /* The I386 case can be handled without a search.  The Alpha case	*/
-  /* used to be handled differently as well, but the rules changed	*/
-  /* for recent Linux versions.  This seems to be the easiest way to	*/
-  /* cover all versions.						*/
+  /* The I386 case can be handled without a search.  The Alpha case */
+  /* used to be handled differently as well, but the rules changed  */
+  /* for recent Linux versions.  This seems to be the easiest way to  */
+  /* cover all versions.            */
 
 # ifdef LINUX
-    /* Some Linux distributions arrange to define __data_start.  Some	*/
-    /* define data_start as a weak symbol.  The latter is technically	*/
-    /* broken, since the user program may define data_start, in which	*/
-    /* case we lose.  Nonetheless, we try both, prefering __data_start.	*/
-    /* We assume gcc-compatible pragmas.	*/
+    /* Some Linux distributions arrange to define __data_start.  Some */
+    /* define data_start as a weak symbol.  The latter is technically */
+    /* broken, since the user program may define data_start, in which */
+    /* case we lose.  Nonetheless, we try both, prefering __data_start. */
+    /* We assume gcc-compatible pragmas.  */
 #   pragma weak __data_start
     extern int __data_start[];
 #   pragma weak data_start
@@ -332,14 +332,14 @@
     extern ptr_t GC_find_limit();
 
 #   ifdef LINUX
-      /* Try the easy approaches first:	*/
+      /* Try the easy approaches first: */
       if ((ptr_t)__data_start != 0) {
-	  GC_data_start = (ptr_t)(__data_start);
-	  return;
+    GC_data_start = (ptr_t)(__data_start);
+    return;
       }
       if ((ptr_t)data_start != 0) {
-	  GC_data_start = (ptr_t)(data_start);
-	  return;
+    GC_data_start = (ptr_t)(data_start);
+    return;
       }
 #   endif /* LINUX */
     GC_data_start = GC_find_limit((ptr_t)(_end), FALSE);
@@ -387,8 +387,8 @@
   {
     extern ptr_t GC_find_limit();
     extern char **environ;
-	/* This may need to be environ, without the underscore, for	*/
-	/* some versions.						*/
+  /* This may need to be environ, without the underscore, for */
+  /* some versions.           */
     GC_data_start = GC_find_limit((ptr_t)&environ, FALSE);
   }
 #endif
@@ -406,19 +406,19 @@
 };
 
 #define E_MAGIC(x)      (x).magic_number
-#define EMAGIC          0x5A4D  
+#define EMAGIC          0x5A4D
 #define E_LFANEW(x)     (x).new_exe_offset
 
 struct e32_exe {
-    unsigned char       magic_number[2]; 
-    unsigned char       byte_order; 
-    unsigned char       word_order; 
+    unsigned char       magic_number[2];
+    unsigned char       byte_order;
+    unsigned char       word_order;
     unsigned long       exe_format_level;
-    unsigned short      cpu;       
+    unsigned short      cpu;
     unsigned short      os;
     unsigned long       padding1[13];
     unsigned long       object_table_offset;
-    unsigned long       object_count;    
+    unsigned long       object_count;
     unsigned long       padding2[31];
 };
 
@@ -436,11 +436,11 @@
 #define E32_OBJCNT(x)   (x).object_count
 
 struct o32_obj {
-    unsigned long       size;  
+    unsigned long       size;
     unsigned long       base;
-    unsigned long       flags;  
+    unsigned long       flags;
     unsigned long       pagemap;
-    unsigned long       mapsize; 
+    unsigned long       mapsize;
     unsigned long       reserved;
 };
 
@@ -475,12 +475,12 @@
 # include <os2.h>
 
 
-/* Disable and enable signals during nontrivial allocations	*/
+/* Disable and enable signals during nontrivial allocations */
 
 void GC_disable_signals(void)
 {
     ULONG nest;
-    
+
     DosEnterMustComplete(&nest);
     if (nest != 1) ABORT("nested GC_disable_signals");
 }
@@ -488,7 +488,7 @@
 void GC_enable_signals(void)
 {
     ULONG nest;
-    
+
     DosExitMustComplete(&nest);
     if (nest != 0) ABORT("GC_enable_signals");
 }
@@ -502,20 +502,20 @@
       && !defined(NOSYS) && !defined(ECOS)
 
 #   if defined(sigmask) && !defined(UTS4) && !defined(HURD)
-	/* Use the traditional BSD interface */
-#	define SIGSET_T int
-#	define SIG_DEL(set, signal) (set) &= ~(sigmask(signal))
-#	define SIG_FILL(set)  (set) = 0x7fffffff
-    	  /* Setting the leading bit appears to provoke a bug in some	*/
-    	  /* longjmp implementations.  Most systems appear not to have	*/
-    	  /* a signal 32.						*/
-#	define SIGSETMASK(old, new) (old) = sigsetmask(new)
+  /* Use the traditional BSD interface */
+# define SIGSET_T int
+# define SIG_DEL(set, signal) (set) &= ~(sigmask(signal))
+# define SIG_FILL(set)  (set) = 0x7fffffff
+        /* Setting the leading bit appears to provoke a bug in some */
+        /* longjmp implementations.  Most systems appear not to have  */
+        /* a signal 32.           */
+# define SIGSETMASK(old, new) (old) = sigsetmask(new)
 #   else
-	/* Use POSIX/SYSV interface	*/
-#	define SIGSET_T sigset_t
-#	define SIG_DEL(set, signal) sigdelset(&(set), (signal))
-#	define SIG_FILL(set) sigfillset(&set)
-#	define SIGSETMASK(old, new) sigprocmask(SIG_SETMASK, &(new), &(old))
+  /* Use POSIX/SYSV interface */
+# define SIGSET_T sigset_t
+# define SIG_DEL(set, signal) sigdelset(&(set), (signal))
+# define SIG_FILL(set) sigfillset(&set)
+# define SIGSETMASK(old, new) sigprocmask(SIG_SETMASK, &(new), &(old))
 #   endif
 
 static GC_bool mask_initialized = FALSE;
@@ -534,28 +534,28 @@
 void GC_disable_signals()
 {
     if (!mask_initialized) {
-    	SIG_FILL(new_mask);
+      SIG_FILL(new_mask);
 
-	SIG_DEL(new_mask, SIGSEGV);
-	SIG_DEL(new_mask, SIGILL);
-	SIG_DEL(new_mask, SIGQUIT);
-#	ifdef SIGBUS
-	    SIG_DEL(new_mask, SIGBUS);
-#	endif
-#	ifdef SIGIOT
-	    SIG_DEL(new_mask, SIGIOT);
-#	endif
-#	ifdef SIGEMT
-	    SIG_DEL(new_mask, SIGEMT);
-#	endif
-#	ifdef SIGTRAP
-	    SIG_DEL(new_mask, SIGTRAP);
-#	endif 
-	mask_initialized = TRUE;
+  SIG_DEL(new_mask, SIGSEGV);
+  SIG_DEL(new_mask, SIGILL);
+  SIG_DEL(new_mask, SIGQUIT);
+# ifdef SIGBUS
+      SIG_DEL(new_mask, SIGBUS);
+# endif
+# ifdef SIGIOT
+      SIG_DEL(new_mask, SIGIOT);
+# endif
+# ifdef SIGEMT
+      SIG_DEL(new_mask, SIGEMT);
+# endif
+# ifdef SIGTRAP
+      SIG_DEL(new_mask, SIGTRAP);
+# endif
+  mask_initialized = TRUE;
     }
 #   ifdef CHECK_SIGNALS
-	if (GC_sig_disabled != 0) ABORT("Nested disables");
-	GC_sig_disabled++;
+  if (GC_sig_disabled != 0) ABORT("Nested disables");
+  GC_sig_disabled++;
 #   endif
     SIGSETMASK(old_mask,new_mask);
 }
@@ -563,8 +563,8 @@
 void GC_enable_signals()
 {
 #   ifdef CHECK_SIGNALS
-	if (GC_sig_disabled != 1) ABORT("Unmatched enable");
-	GC_sig_disabled--;
+  if (GC_sig_disabled != 1) ABORT("Unmatched enable");
+  GC_sig_disabled--;
 #   endif
     SIGSETMASK(dummy,old_mask);
 }
@@ -592,40 +592,40 @@
 # else
 #   if defined(MPROTECT_VDB) || defined(PROC_VDB) || defined(USE_MMAP) \
        || defined(USE_MUNMAP)
-	void GC_setpagesize()
-	{
-	    GC_page_size = GETPAGESIZE();
-	}
+  void GC_setpagesize()
+  {
+      GC_page_size = GETPAGESIZE();
+  }
 #   else
-	/* It's acceptable to fake it. */
-	void GC_setpagesize()
-	{
-	    GC_page_size = HBLKSIZE;
-	}
+  /* It's acceptable to fake it. */
+  void GC_setpagesize()
+  {
+      GC_page_size = HBLKSIZE;
+  }
 #   endif
 # endif
 
-/* 
- * Find the base of the stack. 
+/*
+ * Find the base of the stack.
  * Used only in single-threaded environment.
  * With threads, GC_mark_roots needs to know how to do this.
  * Called with allocator lock held.
  */
 # if defined(MSWIN32) || defined(MSWINCE)
 # define is_writable(prot) ((prot) == PAGE_READWRITE \
-			    || (prot) == PAGE_WRITECOPY \
-			    || (prot) == PAGE_EXECUTE_READWRITE \
-			    || (prot) == PAGE_EXECUTE_WRITECOPY)
-/* Return the number of bytes that are writable starting at p.	*/
-/* The pointer p is assumed to be page aligned.			*/
-/* If base is not 0, *base becomes the beginning of the 	*/
-/* allocation region containing p.				*/
+          || (prot) == PAGE_WRITECOPY \
+          || (prot) == PAGE_EXECUTE_READWRITE \
+          || (prot) == PAGE_EXECUTE_WRITECOPY)
+/* Return the number of bytes that are writable starting at p.  */
+/* The pointer p is assumed to be page aligned.     */
+/* If base is not 0, *base becomes the beginning of the   */
+/* allocation region containing p.        */
 word GC_get_writable_length(ptr_t p, ptr_t *base)
 {
     MEMORY_BASIC_INFORMATION buf;
     word result;
     word protect;
-    
+
     result = VirtualQuery(p, &buf, sizeof(buf));
     if (result != sizeof(buf)) ABORT("Weird VirtualQuery result");
     if (base != 0) *base = (ptr_t)(buf.AllocationBase);
@@ -643,7 +643,7 @@
     ptr_t sp = (ptr_t)(&dummy);
     ptr_t trunc_sp = (ptr_t)((word)sp & ~(GC_page_size - 1));
     word size = GC_get_writable_length(trunc_sp, 0);
-   
+
     return(trunc_sp + size);
 }
 
@@ -653,9 +653,9 @@
 # ifdef BEOS
 # include <kernel/OS.h>
 ptr_t GC_get_stack_base(){
-	thread_info th;
-	get_thread_info(find_thread(NULL),&th);
-	return th.stack_end;
+  thread_info th;
+  get_thread_info(find_thread(NULL),&th);
+  return th.stack_end;
 }
 # endif /* BEOS */
 
@@ -666,10 +666,10 @@
 {
     PTIB ptib;
     PPIB ppib;
-    
+
     if (DosGetInfoBlocks(&ptib, &ppib) != NO_ERROR) {
-    	GC_err_printf0("DosGetInfoBlocks failed\n");
-    	ABORT("DosGetInfoBlocks failed\n");
+      GC_err_printf0("DosGetInfoBlocks failed\n");
+      ABORT("DosGetInfoBlocks failed\n");
     }
     return((ptr_t)(ptib -> tib_pstacklimit));
 }
@@ -685,22 +685,22 @@
 # if defined(NEED_FIND_LIMIT) || defined(UNIX_LIKE)
 
 #   ifdef __STDC__
-	typedef void (*handler)(int);
+  typedef void (*handler)(int);
 #   else
-	typedef void (*handler)();
+  typedef void (*handler)();
 #   endif
 
 #   if defined(SUNOS5SIGS) || defined(IRIX5) || defined(OSF1) \
     || defined(HURD) || defined(NETBSD)
-	static struct sigaction old_segv_act;
-#	if defined(IRIX5) || defined(HPUX) \
-	|| defined(HURD) || defined(NETBSD)
-	    static struct sigaction old_bus_act;
-#	endif
+  static struct sigaction old_segv_act;
+# if defined(IRIX5) || defined(HPUX) \
+  || defined(HURD) || defined(NETBSD)
+      static struct sigaction old_bus_act;
+# endif
 #   else
         static handler old_segv_handler, old_bus_handler;
 #   endif
-    
+
 #   ifdef __STDC__
       void GC_set_and_save_fault_handler(handler h)
 #   else
@@ -708,50 +708,50 @@
       handler h;
 #   endif
     {
-#	if defined(SUNOS5SIGS) || defined(IRIX5)  \
+# if defined(SUNOS5SIGS) || defined(IRIX5)  \
         || defined(OSF1) || defined(HURD) || defined(NETBSD)
-	  struct sigaction	act;
+    struct sigaction  act;
 
-	  act.sa_handler	= h;
-#	  if 0 /* Was necessary for Solaris 2.3 and very temporary 	*/
-	       /* NetBSD bugs.						*/
+    act.sa_handler  = h;
+#   if 0 /* Was necessary for Solaris 2.3 and very temporary  */
+         /* NetBSD bugs.            */
             act.sa_flags          = SA_RESTART | SA_NODEFER;
 #         else
             act.sa_flags          = SA_RESTART;
-#	  endif
+#   endif
 
-	  (void) sigemptyset(&act.sa_mask);
-#	  ifdef GC_IRIX_THREADS
-		/* Older versions have a bug related to retrieving and	*/
-		/* and setting a handler at the same time.		*/
-	        (void) sigaction(SIGSEGV, 0, &old_segv_act);
-	        (void) sigaction(SIGSEGV, &act, 0);
-	        (void) sigaction(SIGBUS, 0, &old_bus_act);
-	        (void) sigaction(SIGBUS, &act, 0);
-#	  else
-	        (void) sigaction(SIGSEGV, &act, &old_segv_act);
-#		if defined(IRIX5) \
-		   || defined(HPUX) || defined(HURD) || defined(NETBSD)
-		    /* Under Irix 5.x or HP/UX, we may get SIGBUS.	*/
-		    /* Pthreads doesn't exist under Irix 5.x, so we	*/
-		    /* don't have to worry in the threads case.		*/
-		    (void) sigaction(SIGBUS, &act, &old_bus_act);
-#		endif
-#	  endif	/* GC_IRIX_THREADS */
-#	else
-    	  old_segv_handler = signal(SIGSEGV, h);
-#	  ifdef SIGBUS
-	    old_bus_handler = signal(SIGBUS, h);
-#	  endif
-#	endif
+    (void) sigemptyset(&act.sa_mask);
+#   ifdef GC_IRIX_THREADS
+    /* Older versions have a bug related to retrieving and  */
+    /* and setting a handler at the same time.    */
+          (void) sigaction(SIGSEGV, 0, &old_segv_act);
+          (void) sigaction(SIGSEGV, &act, 0);
+          (void) sigaction(SIGBUS, 0, &old_bus_act);
+          (void) sigaction(SIGBUS, &act, 0);
+#   else
+          (void) sigaction(SIGSEGV, &act, &old_segv_act);
+#   if defined(IRIX5) \
+       || defined(HPUX) || defined(HURD) || defined(NETBSD)
+        /* Under Irix 5.x or HP/UX, we may get SIGBUS.  */
+        /* Pthreads doesn't exist under Irix 5.x, so we */
+        /* don't have to worry in the threads case.   */
+        (void) sigaction(SIGBUS, &act, &old_bus_act);
+#   endif
+#   endif /* GC_IRIX_THREADS */
+# else
+        old_segv_handler = signal(SIGSEGV, h);
+#   ifdef SIGBUS
+      old_bus_handler = signal(SIGBUS, h);
+#   endif
+# endif
     }
 # endif /* NEED_FIND_LIMIT || UNIX_LIKE */
 
 # ifdef NEED_FIND_LIMIT
-  /* Some tools to implement HEURISTIC2	*/
-#   define MIN_PAGE_SIZE 256	/* Smallest conceivable page size, bytes */
+  /* Some tools to implement HEURISTIC2 */
+#   define MIN_PAGE_SIZE 256  /* Smallest conceivable page size, bytes */
     /* static */ JMP_BUF GC_jmp_buf;
-    
+
     /*ARGSUSED*/
     void GC_fault_handler(sig)
     int sig;
@@ -761,58 +761,58 @@
 
     void GC_setup_temporary_fault_handler()
     {
-	GC_set_and_save_fault_handler(GC_fault_handler);
+  GC_set_and_save_fault_handler(GC_fault_handler);
     }
-    
+
     void GC_reset_fault_handler()
     {
 #       if defined(SUNOS5SIGS) || defined(IRIX5) \
-	   || defined(OSF1) || defined(HURD) || defined(NETBSD)
-	  (void) sigaction(SIGSEGV, &old_segv_act, 0);
-#	  if defined(IRIX5) \
-	     || defined(HPUX) || defined(HURD) || defined(NETBSD)
-	      (void) sigaction(SIGBUS, &old_bus_act, 0);
-#	  endif
+     || defined(OSF1) || defined(HURD) || defined(NETBSD)
+    (void) sigaction(SIGSEGV, &old_segv_act, 0);
+#   if defined(IRIX5) \
+       || defined(HPUX) || defined(HURD) || defined(NETBSD)
+        (void) sigaction(SIGBUS, &old_bus_act, 0);
+#   endif
 #       else
-  	  (void) signal(SIGSEGV, old_segv_handler);
-#	  ifdef SIGBUS
-	    (void) signal(SIGBUS, old_bus_handler);
-#	  endif
+      (void) signal(SIGSEGV, old_segv_handler);
+#   ifdef SIGBUS
+      (void) signal(SIGBUS, old_bus_handler);
+#   endif
 #       endif
     }
 
-    /* Return the first nonaddressible location > p (up) or 	*/
-    /* the smallest location q s.t. [q,p) is addressable (!up).	*/
-    /* We assume that p (up) or p-1 (!up) is addressable.	*/
+    /* Return the first nonaddressible location > p (up) or   */
+    /* the smallest location q s.t. [q,p) is addressable (!up). */
+    /* We assume that p (up) or p-1 (!up) is addressable. */
     ptr_t GC_find_limit(p, up)
     ptr_t p;
     GC_bool up;
     {
         static VOLATILE ptr_t result;
-    		/* Needs to be static, since otherwise it may not be	*/
-    		/* preserved across the longjmp.  Can safely be 	*/
-    		/* static since it's only called once, with the		*/
-    		/* allocation lock held.				*/
+        /* Needs to be static, since otherwise it may not be  */
+        /* preserved across the longjmp.  Can safely be   */
+        /* static since it's only called once, with the   */
+        /* allocation lock held.        */
 
 
-	GC_setup_temporary_fault_handler();
-	if (SETJMP(GC_jmp_buf) == 0) {
-	    result = (ptr_t)(((word)(p))
-			      & ~(MIN_PAGE_SIZE-1));
-	    for (;;) {
- 	        if (up) {
-		    result += MIN_PAGE_SIZE;
- 	        } else {
-		    result -= MIN_PAGE_SIZE;
- 	        }
-		GC_noop1((word)(*result));
-	    }
-	}
-	GC_reset_fault_handler();
- 	if (!up) {
-	    result += MIN_PAGE_SIZE;
- 	}
-	return(result);
+  GC_setup_temporary_fault_handler();
+  if (SETJMP(GC_jmp_buf) == 0) {
+      result = (ptr_t)(((word)(p))
+            & ~(MIN_PAGE_SIZE-1));
+      for (;;) {
+          if (up) {
+        result += MIN_PAGE_SIZE;
+          } else {
+        result -= MIN_PAGE_SIZE;
+          }
+    GC_noop1((word)(*result));
+      }
+  }
+  GC_reset_fault_handler();
+  if (!up) {
+      result += MIN_PAGE_SIZE;
+  }
+  return(result);
     }
 # endif
 
@@ -851,8 +851,8 @@
 #include <sys/types.h>
 #include <sys/stat.h>
 
-# define STAT_SKIP 27   /* Number of fields preceding startstack	*/
-			/* field in /proc/self/stat			*/
+# define STAT_SKIP 27   /* Number of fields preceding startstack  */
+      /* field in /proc/self/stat     */
 
 #ifdef USE_LIBC_PRIVATES
 # pragma weak __libc_stack_end
@@ -860,9 +860,9 @@
 #endif
 
 # ifdef IA64
-    /* Try to read the backing store base from /proc/self/maps.	*/
+    /* Try to read the backing store base from /proc/self/maps. */
     /* We look for the writable mapping with a 0 major device,  */
-    /* which is	as close to our frame as possible, but below it.*/
+    /* which is as close to our frame as possible, but below it.*/
     static word backing_store_base_from_maps(char *maps)
     {
       char prot_buf[5];
@@ -871,13 +871,13 @@
       unsigned int maj_dev;
       word current_best = 0;
       word dummy;
-  
+
       for (;;) {
         buf_ptr = GC_parse_map_entry(buf_ptr, &start, &end, prot_buf, &maj_dev);
-	if (buf_ptr == NULL) return current_best;
-	if (prot_buf[1] == 'w' && maj_dev == 0) {
-	    if (end < (word)(&dummy) && start > current_best) current_best = start;
-	}
+  if (buf_ptr == NULL) return current_best;
+  if (prot_buf[1] == 'w' && maj_dev == 0) {
+      if (end < (word)(&dummy) && start > current_best) current_best = start;
+  }
       }
       return current_best;
     }
@@ -896,22 +896,22 @@
     {
 #     ifdef USE_LIBC_PRIVATES
         if (0 != &__libc_ia64_register_backing_store_base
-	    && 0 != __libc_ia64_register_backing_store_base) {
-	  /* Glibc 2.2.4 has a bug such that for dynamically linked	*/
-	  /* executables __libc_ia64_register_backing_store_base is 	*/
-	  /* defined but uninitialized during constructor calls.  	*/
-	  /* Hence we check for both nonzero address and value.		*/
-	  return __libc_ia64_register_backing_store_base;
+      && 0 != __libc_ia64_register_backing_store_base) {
+    /* Glibc 2.2.4 has a bug such that for dynamically linked */
+    /* executables __libc_ia64_register_backing_store_base is   */
+    /* defined but uninitialized during constructor calls.    */
+    /* Hence we check for both nonzero address and value.   */
+    return __libc_ia64_register_backing_store_base;
         }
 #     endif
       word result = backing_store_base_from_proc();
       if (0 == result) {
-	  /* Use dumb heuristics.  Works only for default configuration. */
-	  result = (word)GC_stackbottom - BACKING_STORE_DISPLACEMENT;
-	  result += BACKING_STORE_ALIGNMENT - 1;
-	  result &= ~(BACKING_STORE_ALIGNMENT - 1);
-	  /* Verify that it's at least readable.  If not, we goofed. */
-	  GC_noop1(*(word *)result); 
+    /* Use dumb heuristics.  Works only for default configuration. */
+    result = (word)GC_stackbottom - BACKING_STORE_DISPLACEMENT;
+    result += BACKING_STORE_ALIGNMENT - 1;
+    result &= ~(BACKING_STORE_ALIGNMENT - 1);
+    /* Verify that it's at least readable.  If not, we goofed. */
+    GC_noop1(*(word *)result);
       }
       return (ptr_t)result;
     }
@@ -919,56 +919,56 @@
 
   ptr_t GC_linux_stack_base(void)
   {
-    /* We read the stack base value from /proc/self/stat.  We do this	*/
+    /* We read the stack base value from /proc/self/stat.  We do this */
     /* using direct I/O system calls in order to avoid calling malloc   */
-    /* in case REDIRECT_MALLOC is defined.				*/ 
+    /* in case REDIRECT_MALLOC is defined.        */
 #   define STAT_BUF_SIZE 4096
 #   define STAT_READ read
-	  /* Should probably call the real read, if read is wrapped.	*/
+    /* Should probably call the real read, if read is wrapped.  */
     char stat_buf[STAT_BUF_SIZE];
     int f;
     char c;
     word result = 0;
     size_t i, buf_offset = 0;
 
-    /* First try the easy way.  This should work for glibc 2.2	*/
+    /* First try the easy way.  This should work for glibc 2.2  */
     /* This fails in a prelinked ("prelink" command) executable */
-    /* since the correct value of __libc_stack_end never	*/
-    /* becomes visible to us.  The second test works around 	*/
-    /* this.							*/  
+    /* since the correct value of __libc_stack_end never  */
+    /* becomes visible to us.  The second test works around   */
+    /* this.              */
 #   ifdef USE_LIBC_PRIVATES
       if (0 != &__libc_stack_end && 0 != __libc_stack_end ) {
 #       ifdef IA64
-	  /* Some versions of glibc set the address 16 bytes too	*/
-	  /* low while the initialization code is running.		*/
-	  if (((word)__libc_stack_end & 0xfff) + 0x10 < 0x1000) {
-	    return __libc_stack_end + 0x10;
-	  } /* Otherwise it's not safe to add 16 bytes and we fall	*/
-	    /* back to using /proc.					*/
-#	else 
-#	ifdef SPARC
-	  /* Older versions of glibc for 64-bit Sparc do not set
-	   * this variable correctly, it gets set to either zero
-	   * or one.
-	   */
-	  if (__libc_stack_end != (ptr_t) (unsigned long)0x1)
-	    return __libc_stack_end;
-#	else
-	  return __libc_stack_end;
-#	endif
-#	endif
+    /* Some versions of glibc set the address 16 bytes too  */
+    /* low while the initialization code is running.    */
+    if (((word)__libc_stack_end & 0xfff) + 0x10 < 0x1000) {
+      return __libc_stack_end + 0x10;
+    } /* Otherwise it's not safe to add 16 bytes and we fall  */
+      /* back to using /proc.         */
+# else
+# ifdef SPARC
+    /* Older versions of glibc for 64-bit Sparc do not set
+     * this variable correctly, it gets set to either zero
+     * or one.
+     */
+    if (__libc_stack_end != (ptr_t) (unsigned long)0x1)
+      return __libc_stack_end;
+# else
+    return __libc_stack_end;
+# endif
+# endif
       }
 #   endif
     f = open("/proc/self/stat", O_RDONLY);
     if (f < 0 || STAT_READ(f, stat_buf, STAT_BUF_SIZE) < 2 * STAT_SKIP) {
-	ABORT("Couldn't read /proc/self/stat");
+  ABORT("Couldn't read /proc/self/stat");
     }
     c = stat_buf[buf_offset++];
-    /* Skip the required number of fields.  This number is hopefully	*/
-    /* constant across all Linux implementations.			*/
+    /* Skip the required number of fields.  This number is hopefully  */
+    /* constant across all Linux implementations.     */
       for (i = 0; i < STAT_SKIP; ++i) {
-	while (isspace(c)) c = stat_buf[buf_offset++];
-	while (!isspace(c)) c = stat_buf[buf_offset++];
+  while (isspace(c)) c = stat_buf[buf_offset++];
+  while (!isspace(c)) c = stat_buf[buf_offset++];
       }
     while (isspace(c)) c = stat_buf[buf_offset++];
     while (isdigit(c)) {
@@ -985,8 +985,8 @@
 
 #ifdef FREEBSD_STACKBOTTOM
 
-/* This uses an undocumented sysctl call, but at least one expert 	*/
-/* believes it will stay.						*/
+/* This uses an undocumented sysctl call, but at least one expert   */
+/* believes it will stay.           */
 
 #include <unistd.h>
 #include <sys/types.h>
@@ -998,7 +998,7 @@
     ptr_t base;
     size_t len = sizeof(ptr_t);
     int r = sysctl(nm, 2, &base, &len, NULL, 0);
-    
+
     if (r) ABORT("Error getting stack base");
 
     return base;
@@ -1020,48 +1020,48 @@
 #   define STACKBOTTOM_ALIGNMENT_M1 ((word)STACK_GRAN - 1)
 
 #   ifdef STACKBOTTOM
-	return(STACKBOTTOM);
+  return(STACKBOTTOM);
 #   else
-#	ifdef HEURISTIC1
-#	   ifdef STACK_GROWS_DOWN
-	     result = (ptr_t)((((word)(&dummy))
-	     		       + STACKBOTTOM_ALIGNMENT_M1)
-			      & ~STACKBOTTOM_ALIGNMENT_M1);
-#	   else
-	     result = (ptr_t)(((word)(&dummy))
-			      & ~STACKBOTTOM_ALIGNMENT_M1);
-#	   endif
-#	endif /* HEURISTIC1 */
-#	ifdef LINUX_STACKBOTTOM
-	   result = GC_linux_stack_base();
-#	endif
-#	ifdef FREEBSD_STACKBOTTOM
-	   result = GC_freebsd_stack_base();
-#	endif
-#	ifdef HEURISTIC2
-#	    ifdef STACK_GROWS_DOWN
-		result = GC_find_limit((ptr_t)(&dummy), TRUE);
-#           	ifdef HEURISTIC2_LIMIT
-		    if (result > HEURISTIC2_LIMIT
-		        && (ptr_t)(&dummy) < HEURISTIC2_LIMIT) {
-		            result = HEURISTIC2_LIMIT;
-		    }
-#	        endif
-#	    else
-		result = GC_find_limit((ptr_t)(&dummy), FALSE);
-#           	ifdef HEURISTIC2_LIMIT
-		    if (result < HEURISTIC2_LIMIT
-		        && (ptr_t)(&dummy) > HEURISTIC2_LIMIT) {
-		            result = HEURISTIC2_LIMIT;
-		    }
-#	        endif
-#	    endif
+# ifdef HEURISTIC1
+#    ifdef STACK_GROWS_DOWN
+       result = (ptr_t)((((word)(&dummy))
+                 + STACKBOTTOM_ALIGNMENT_M1)
+            & ~STACKBOTTOM_ALIGNMENT_M1);
+#    else
+       result = (ptr_t)(((word)(&dummy))
+            & ~STACKBOTTOM_ALIGNMENT_M1);
+#    endif
+# endif /* HEURISTIC1 */
+# ifdef LINUX_STACKBOTTOM
+     result = GC_linux_stack_base();
+# endif
+# ifdef FREEBSD_STACKBOTTOM
+     result = GC_freebsd_stack_base();
+# endif
+# ifdef HEURISTIC2
+#     ifdef STACK_GROWS_DOWN
+    result = GC_find_limit((ptr_t)(&dummy), TRUE);
+#             ifdef HEURISTIC2_LIMIT
+        if (result > HEURISTIC2_LIMIT
+            && (ptr_t)(&dummy) < HEURISTIC2_LIMIT) {
+                result = HEURISTIC2_LIMIT;
+        }
+#         endif
+#     else
+    result = GC_find_limit((ptr_t)(&dummy), FALSE);
+#             ifdef HEURISTIC2_LIMIT
+        if (result < HEURISTIC2_LIMIT
+            && (ptr_t)(&dummy) > HEURISTIC2_LIMIT) {
+                result = HEURISTIC2_LIMIT;
+        }
+#         endif
+#     endif
 
-#	endif /* HEURISTIC2 */
-#	ifdef STACK_GROWS_DOWN
-	    if (result == 0) result = (ptr_t)(signed_word)(-sizeof(ptr_t));
-#	endif
-    	return(result);
+# endif /* HEURISTIC2 */
+# ifdef STACK_GROWS_DOWN
+      if (result == 0) result = (ptr_t)(signed_word)(-sizeof(ptr_t));
+# endif
+      return(result);
 #   endif /* STACKBOTTOM */
 }
 
@@ -1085,20 +1085,20 @@
 #   define PBUFSIZ 512
     UCHAR path[PBUFSIZ];
     FILE * myexefile;
-    struct exe_hdr hdrdos;	/* MSDOS header.	*/
-    struct e32_exe hdr386;	/* Real header for my executable */
-    struct o32_obj seg;	/* Currrent segment */
+    struct exe_hdr hdrdos;  /* MSDOS header.  */
+    struct e32_exe hdr386;  /* Real header for my executable */
+    struct o32_obj seg; /* Currrent segment */
     int nsegs;
-    
-    
+
+
     if (DosGetInfoBlocks(&ptib, &ppib) != NO_ERROR) {
-    	GC_err_printf0("DosGetInfoBlocks failed\n");
-    	ABORT("DosGetInfoBlocks failed\n");
+      GC_err_printf0("DosGetInfoBlocks failed\n");
+      ABORT("DosGetInfoBlocks failed\n");
     }
     module_handle = ppib -> pib_hmte;
     if (DosQueryModuleName(module_handle, PBUFSIZ, path) != NO_ERROR) {
-    	GC_err_printf0("DosQueryModuleName failed\n");
-    	ABORT("DosGetInfoBlocks failed\n");
+      GC_err_printf0("DosQueryModuleName failed\n");
+      ABORT("DosGetInfoBlocks failed\n");
     }
     myexefile = fopen(path, "rb");
     if (myexefile == 0) {
@@ -1142,7 +1142,7 @@
         EXIT();
     }
     if (fseek(myexefile, E_LFANEW(hdrdos) + E32_OBJTAB(hdr386),
-    	      SEEK_SET) != 0) {
+            SEEK_SET) != 0) {
         GC_err_puts("Seek to object table failed: ");
         GC_err_puts(path); GC_err_puts("\n");
         ABORT("Seek to object table failed");
@@ -1160,7 +1160,7 @@
       if (flags & OBJINVALID) {
           GC_err_printf0("Object with invalid pages?\n");
           continue;
-      } 
+      }
       GC_add_roots_inner(O32_BASE(seg), O32_BASE(seg)+O32_SIZE(seg), FALSE);
     }
 }
@@ -1170,20 +1170,20 @@
 # if defined(MSWIN32) || defined(MSWINCE)
 
 # ifdef MSWIN32
-  /* Unfortunately, we have to handle win32s very differently from NT, 	*/
-  /* Since VirtualQuery has very different semantics.  In particular,	*/
-  /* under win32s a VirtualQuery call on an unmapped page returns an	*/
-  /* invalid result.  Under NT, GC_register_data_segments is a noop and	*/
-  /* all real work is done by GC_register_dynamic_libraries.  Under	*/
-  /* win32s, we cannot find the data segments associated with dll's.	*/
-  /* We register the main data segment here.				*/
-  GC_bool GC_no_win32_dlls = FALSE;	 
-  	/* This used to be set for gcc, to avoid dealing with		*/
-  	/* the structured exception handling issues.  But we now have	*/
-  	/* assembly code to do that right.				*/
+  /* Unfortunately, we have to handle win32s very differently from NT,  */
+  /* Since VirtualQuery has very different semantics.  In particular, */
+  /* under win32s a VirtualQuery call on an unmapped page returns an  */
+  /* invalid result.  Under NT, GC_register_data_segments is a noop and */
+  /* all real work is done by GC_register_dynamic_libraries.  Under */
+  /* win32s, we cannot find the data segments associated with dll's.  */
+  /* We register the main data segment here.        */
+  GC_bool GC_no_win32_dlls = FALSE;
+    /* This used to be set for gcc, to avoid dealing with   */
+    /* the structured exception handling issues.  But we now have */
+    /* assembly code to do that right.        */
   GC_bool GC_wnt = FALSE;
         /* This is a Windows NT derivative, i.e. NT, W2K, XP or later.  */
-  
+
   void GC_init_win32()
   {
     /* if we're running under win32s, assume that no DLLs will be loaded */
@@ -1192,48 +1192,48 @@
     GC_no_win32_dlls |= ((!GC_wnt) && (v & 0xff) <= 3);
   }
 
-  /* Return the smallest address a such that VirtualQuery		*/
-  /* returns correct results for all addresses between a and start.	*/
-  /* Assumes VirtualQuery returns correct information for start.	*/
+  /* Return the smallest address a such that VirtualQuery   */
+  /* returns correct results for all addresses between a and start. */
+  /* Assumes VirtualQuery returns correct information for start.  */
   ptr_t GC_least_described_address(ptr_t start)
-  {  
+  {
     MEMORY_BASIC_INFORMATION buf;
     DWORD result;
     LPVOID limit;
     ptr_t p;
     LPVOID q;
-    
+
     limit = GC_sysinfo.lpMinimumApplicationAddress;
     p = (ptr_t)((word)start & ~(GC_page_size - 1));
     for (;;) {
-    	q = (LPVOID)(p - GC_page_size);
-    	if ((ptr_t)q > (ptr_t)p /* underflow */ || q < limit) break;
-    	result = VirtualQuery(q, &buf, sizeof(buf));
-    	if (result != sizeof(buf) || buf.AllocationBase == 0) break;
-    	p = (ptr_t)(buf.AllocationBase);
+      q = (LPVOID)(p - GC_page_size);
+      if ((ptr_t)q > (ptr_t)p /* underflow */ || q < limit) break;
+      result = VirtualQuery(q, &buf, sizeof(buf));
+      if (result != sizeof(buf) || buf.AllocationBase == 0) break;
+      p = (ptr_t)(buf.AllocationBase);
     }
     return(p);
   }
 # endif
 
 # ifndef REDIRECT_MALLOC
-  /* We maintain a linked list of AllocationBase values that we know	*/
+  /* We maintain a linked list of AllocationBase values that we know  */
   /* correspond to malloc heap sections.  Currently this is only called */
-  /* during a GC.  But there is some hope that for long running		*/
-  /* programs we will eventually see most heap sections.		*/
+  /* during a GC.  But there is some hope that for long running   */
+  /* programs we will eventually see most heap sections.    */
 
-  /* In the long run, it would be more reliable to occasionally walk 	*/
-  /* the malloc heap with HeapWalk on the default heap.  But that	*/
-  /* apparently works only for NT-based Windows. 			*/ 
+  /* In the long run, it would be more reliable to occasionally walk  */
+  /* the malloc heap with HeapWalk on the default heap.  But that */
+  /* apparently works only for NT-based Windows.      */
 
-  /* In the long run, a better data structure would also be nice ...	*/
+  /* In the long run, a better data structure would also be nice ...  */
   struct GC_malloc_heap_list {
     void * allocation_base;
     struct GC_malloc_heap_list *next;
   } *GC_malloc_heap_l = 0;
 
-  /* Is p the base of one of the malloc heap sections we already know	*/
-  /* about?								*/
+  /* Is p the base of one of the malloc heap sections we already know */
+  /* about?               */
   GC_bool GC_is_malloc_heap_base(ptr_t p)
   {
     struct GC_malloc_heap_list *q = GC_malloc_heap_l;
@@ -1255,7 +1255,7 @@
     return buf.AllocationBase;
   }
 
-  size_t GC_max_root_size = 100000;	/* Appr. largest root size.	*/
+  size_t GC_max_root_size = 100000; /* Appr. largest root size. */
 
   void GC_add_current_malloc_heap()
   {
@@ -1265,23 +1265,23 @@
 
     if (new_l == 0) return;
     if (GC_is_malloc_heap_base(candidate)) {
-      /* Try a little harder to find malloc heap.			*/
-	size_t req_size = 10000;
-	do {
-	  void *p = malloc(req_size);
-	  if (0 == p) { free(new_l); return; }
- 	  candidate = GC_get_allocation_base(p);
-	  free(p);
-	  req_size *= 2;
-	} while (GC_is_malloc_heap_base(candidate)
-	         && req_size < GC_max_root_size/10 && req_size < 500000);
-	if (GC_is_malloc_heap_base(candidate)) {
-	  free(new_l); return;
-	}
+      /* Try a little harder to find malloc heap.     */
+  size_t req_size = 10000;
+  do {
+    void *p = malloc(req_size);
+    if (0 == p) { free(new_l); return; }
+    candidate = GC_get_allocation_base(p);
+    free(p);
+    req_size *= 2;
+  } while (GC_is_malloc_heap_base(candidate)
+           && req_size < GC_max_root_size/10 && req_size < 500000);
+  if (GC_is_malloc_heap_base(candidate)) {
+    free(new_l); return;
+  }
     }
 #   ifdef CONDPRINT
       if (GC_print_stats)
-	  GC_printf1("Found new system malloc AllocationBase at 0x%lx\n",
+    GC_printf1("Found new system malloc AllocationBase at 0x%lx\n",
                      candidate);
 #   endif
     new_l -> allocation_base = candidate;
@@ -1289,20 +1289,20 @@
     GC_malloc_heap_l = new_l;
   }
 # endif /* REDIRECT_MALLOC */
-  
+
   /* Is p the start of either the malloc heap, or of one of our */
-  /* heap sections?						*/
+  /* heap sections?           */
   GC_bool GC_is_heap_base (ptr_t p)
   {
-     
+
      unsigned i;
-     
+
 #    ifndef REDIRECT_MALLOC
        static word last_gc_no = -1;
-     
+
        if (last_gc_no != GC_gc_no) {
-	 GC_add_current_malloc_heap();
-	 last_gc_no = GC_gc_no;
+   GC_add_current_malloc_heap();
+   last_gc_no = GC_gc_no;
        }
        if (GC_root_size > GC_max_root_size) GC_max_root_size = GC_root_size;
        if (GC_is_malloc_heap_base(p)) return TRUE;
@@ -1322,7 +1322,7 @@
       LPVOID p;
       char * base;
       char * limit, * new_limit;
-    
+
       if (!GC_no_win32_dlls) return;
       p = base = limit = GC_least_described_address(static_root);
       while (p < GC_sysinfo.lpMaximumApplicationAddress) {
@@ -1347,7 +1347,7 @@
       if (base != limit) GC_add_roots_inner(base, limit, FALSE);
   }
 #endif
-  
+
   void GC_register_data_segments()
   {
 #     ifdef MSWIN32
@@ -1365,60 +1365,60 @@
 int * etext_addr;
 {
     word text_end = ((word)(etext_addr) + sizeof(word) - 1)
-    		    & ~(sizeof(word) - 1);
-    	/* etext rounded to word boundary	*/
+            & ~(sizeof(word) - 1);
+      /* etext rounded to word boundary */
     word next_page = ((text_end + (word)max_page_size - 1)
-    		      & ~((word)max_page_size - 1));
+              & ~((word)max_page_size - 1));
     word page_offset = (text_end & ((word)max_page_size - 1));
     VOLATILE char * result = (char *)(next_page + page_offset);
-    /* Note that this isnt equivalent to just adding		*/
-    /* max_page_size to &etext if &etext is at a page boundary	*/
-    
+    /* Note that this isnt equivalent to just adding    */
+    /* max_page_size to &etext if &etext is at a page boundary  */
+
     GC_setup_temporary_fault_handler();
     if (SETJMP(GC_jmp_buf) == 0) {
-    	/* Try writing to the address.	*/
-    	*result = *result;
+      /* Try writing to the address.  */
+      *result = *result;
         GC_reset_fault_handler();
     } else {
         GC_reset_fault_handler();
-    	/* We got here via a longjmp.  The address is not readable.	*/
-    	/* This is known to happen under Solaris 2.4 + gcc, which place	*/
-    	/* string constants in the text segment, but after etext.	*/
-    	/* Use plan B.  Note that we now know there is a gap between	*/
-    	/* text and data segments, so plan A bought us something.	*/
-    	result = (char *)GC_find_limit((ptr_t)(DATAEND), FALSE);
+      /* We got here via a longjmp.  The address is not readable. */
+      /* This is known to happen under Solaris 2.4 + gcc, which place */
+      /* string constants in the text segment, but after etext. */
+      /* Use plan B.  Note that we now know there is a gap between  */
+      /* text and data segments, so plan A bought us something. */
+      result = (char *)GC_find_limit((ptr_t)(DATAEND), FALSE);
     }
     return((ptr_t)result);
 }
 # endif
 
 # if defined(FREEBSD) && (defined(I386) || defined(powerpc) || defined(__powerpc__)) && !defined(PCR)
-/* Its unclear whether this should be identical to the above, or 	*/
-/* whether it should apply to non-X86 architectures.			*/
-/* For now we don't assume that there is always an empty page after	*/
+/* Its unclear whether this should be identical to the above, or  */
+/* whether it should apply to non-X86 architectures.      */
+/* For now we don't assume that there is always an empty page after */
 /* etext.  But in some cases there actually seems to be slightly more.  */
-/* This also deals with holes between read-only data and writable data.	*/
+/* This also deals with holes between read-only data and writable data. */
 ptr_t GC_FreeBSDGetDataStart(max_page_size, etext_addr)
 int max_page_size;
 int * etext_addr;
 {
     word text_end = ((word)(etext_addr) + sizeof(word) - 1)
-		     & ~(sizeof(word) - 1);
-	/* etext rounded to word boundary	*/
+         & ~(sizeof(word) - 1);
+  /* etext rounded to word boundary */
     VOLATILE word next_page = (text_end + (word)max_page_size - 1)
-			      & ~((word)max_page_size - 1);
+            & ~((word)max_page_size - 1);
     VOLATILE ptr_t result = (ptr_t)text_end;
     GC_setup_temporary_fault_handler();
     if (SETJMP(GC_jmp_buf) == 0) {
-	/* Try reading at the address.				*/
-	/* This should happen before there is another thread.	*/
-	for (; next_page < (word)(DATAEND); next_page += (word)max_page_size)
-	    *(VOLATILE char *)next_page;
-	GC_reset_fault_handler();
+  /* Try reading at the address.        */
+  /* This should happen before there is another thread. */
+  for (; next_page < (word)(DATAEND); next_page += (word)max_page_size)
+      *(VOLATILE char *)next_page;
+  GC_reset_fault_handler();
     } else {
-	GC_reset_fault_handler();
-	/* As above, we go to plan B	*/
-	result = GC_find_limit((ptr_t)(DATAEND), FALSE);
+  GC_reset_fault_handler();
+  /* As above, we go to plan B  */
+  result = GC_find_limit((ptr_t)(DATAEND), FALSE);
     }
     return(result);
 }
@@ -1438,16 +1438,16 @@
 {
 #   if !defined(PCR) && !defined(SRC_M3) && !defined(MACOS)
 #     if defined(REDIRECT_MALLOC) && defined(GC_SOLARIS_THREADS)
-	/* As of Solaris 2.3, the Solaris threads implementation	*/
-	/* allocates the data structure for the initial thread with	*/
-	/* sbrk at process startup.  It needs to be scanned, so that	*/
-	/* we don't lose some malloc allocated data structures		*/
-	/* hanging from it.  We're on thin ice here ...			*/
+  /* As of Solaris 2.3, the Solaris threads implementation  */
+  /* allocates the data structure for the initial thread with */
+  /* sbrk at process startup.  It needs to be scanned, so that  */
+  /* we don't lose some malloc allocated data structures    */
+  /* hanging from it.  We're on thin ice here ...     */
         extern caddr_t sbrk();
 
-	GC_add_roots_inner(DATASTART, (char *)sbrk(0), FALSE);
+  GC_add_roots_inner(DATASTART, (char *)sbrk(0), FALSE);
 #     else
-	GC_add_roots_inner(DATASTART, (char *)(DATAEND), FALSE);
+  GC_add_roots_inner(DATASTART, (char *)(DATAEND), FALSE);
 #       if defined(DATASTART2)
          GC_add_roots_inner(DATASTART2, (char *)(DATAEND2), FALSE);
 #       endif
@@ -1456,31 +1456,31 @@
 #   if defined(MACOS)
     {
 #   if defined(THINK_C)
-	extern void* GC_MacGetDataStart(void);
-	/* globals begin above stack and end at a5. */
-	GC_add_roots_inner((ptr_t)GC_MacGetDataStart(),
-			   (ptr_t)LMGetCurrentA5(), FALSE);
+  extern void* GC_MacGetDataStart(void);
+  /* globals begin above stack and end at a5. */
+  GC_add_roots_inner((ptr_t)GC_MacGetDataStart(),
+         (ptr_t)LMGetCurrentA5(), FALSE);
 #   else
 #     if defined(__MWERKS__)
 #       if !__POWERPC__
-	  extern void* GC_MacGetDataStart(void);
-	  /* MATTHEW: Function to handle Far Globals (CW Pro 3) */
+    extern void* GC_MacGetDataStart(void);
+    /* MATTHEW: Function to handle Far Globals (CW Pro 3) */
 #         if __option(far_data)
-	  extern void* GC_MacGetDataEnd(void);
+    extern void* GC_MacGetDataEnd(void);
 #         endif
-	  /* globals begin above stack and end at a5. */
-	  GC_add_roots_inner((ptr_t)GC_MacGetDataStart(),
-          		     (ptr_t)LMGetCurrentA5(), FALSE);
-	  /* MATTHEW: Handle Far Globals */          		     
+    /* globals begin above stack and end at a5. */
+    GC_add_roots_inner((ptr_t)GC_MacGetDataStart(),
+                   (ptr_t)LMGetCurrentA5(), FALSE);
+    /* MATTHEW: Handle Far Globals */
 #         if __option(far_data)
       /* Far globals follow he QD globals: */
-	  GC_add_roots_inner((ptr_t)LMGetCurrentA5(),
-          		     (ptr_t)GC_MacGetDataEnd(), FALSE);
+    GC_add_roots_inner((ptr_t)LMGetCurrentA5(),
+                   (ptr_t)GC_MacGetDataEnd(), FALSE);
 #         endif
 #       else
-	  extern char __data_start__[], __data_end__[];
-	  GC_add_roots_inner((ptr_t)&__data_start__,
-	  		     (ptr_t)&__data_end__, FALSE);
+    extern char __data_start__[], __data_end__[];
+    GC_add_roots_inner((ptr_t)&__data_start__,
+             (ptr_t)&__data_end__, FALSE);
 #       endif /* __POWERPC__ */
 #     endif /* __MWERKS__ */
 #   endif /* !THINK_C */
@@ -1488,7 +1488,7 @@
 #   endif /* MACOS */
 
     /* Dynamic libraries are added at every collection, since they may  */
-    /* change.								*/
+    /* change.                */
 }
 
 # endif  /* ! AMIGA */
@@ -1500,8 +1500,8 @@
  */
 
 # if !defined(OS2) && !defined(PCR) && !defined(AMIGA) \
-	&& !defined(MSWIN32) && !defined(MSWINCE) \
-	&& !defined(MACOS) && !defined(DOS4GW) && !defined(NONSTOP)
+  && !defined(MSWIN32) && !defined(MSWINCE) \
+  && !defined(MACOS) && !defined(DOS4GW) && !defined(NONSTOP)
 
 # ifdef SUNOS4
     extern caddr_t sbrk();
@@ -1514,9 +1514,9 @@
 
 
 # if 0 && defined(RS6000)  /* We now use mmap */
-/* The compiler seems to generate speculative reads one past the end of	*/
-/* an allocated object.  Hence we need to make sure that the page 	*/
-/* following the last heap page is also mapped.				*/
+/* The compiler seems to generate speculative reads one past the end of */
+/* an allocated object.  Hence we need to make sure that the page   */
+/* following the last heap page is also mapped.       */
 ptr_t GC_unix_get_mem(bytes)
 word bytes;
 {
@@ -1524,13 +1524,13 @@
     caddr_t result;
     SBRK_ARG_T lsbs = (word)cur_brk & (GC_page_size-1);
     static caddr_t my_brk_val = 0;
-    
+
     if ((SBRK_ARG_T)bytes < 0) return(0); /* too big */
     if (lsbs != 0) {
         if((caddr_t)(sbrk(GC_page_size - lsbs)) == (caddr_t)(-1)) return(0);
     }
     if (cur_brk == my_brk_val) {
-    	/* Use the extra block we allocated last time. */
+      /* Use the extra block we allocated last time. */
         result = (ptr_t)sbrk((SBRK_ARG_T)bytes);
         if (result == (caddr_t)(-1)) return(0);
         result -= GC_page_size;
@@ -1538,7 +1538,7 @@
         result = (ptr_t)sbrk(GC_page_size + (SBRK_ARG_T)bytes);
         if (result == (caddr_t)(-1)) return(0);
     }
-    my_brk_val = result + bytes + GC_page_size;	/* Always page aligned */
+    my_brk_val = result + bytes + GC_page_size; /* Always page aligned */
     return((ptr_t)result);
 }
 
@@ -1548,8 +1548,8 @@
 
 #ifdef USE_MMAP_FIXED
 #   define GC_MMAP_FLAGS MAP_FIXED | MAP_PRIVATE
-	/* Seems to yield better performance on Solaris 2, but can	*/
-	/* be unreliable if something is already mapped at the address.	*/
+  /* Seems to yield better performance on Solaris 2, but can  */
+  /* be unreliable if something is already mapped at the address. */
 #else
 #   define GC_MMAP_FLAGS MAP_PRIVATE
 #endif
@@ -1564,7 +1564,7 @@
 #else
   static int zero_fd;
 # define OPT_MAP_ANON 0
-#endif 
+#endif
 
 #endif /* defined(USE_MMAP) || defined(USE_MUNMAP) */
 
@@ -1585,26 +1585,26 @@
       static GC_bool initialized = FALSE;
 
       if (!initialized) {
-	  zero_fd = open("/dev/zero", O_RDONLY);
-	  fcntl(zero_fd, F_SETFD, FD_CLOEXEC);
-	  initialized = TRUE;
+    zero_fd = open("/dev/zero", O_RDONLY);
+    fcntl(zero_fd, F_SETFD, FD_CLOEXEC);
+    initialized = TRUE;
       }
 #   endif
 
     if (bytes & (GC_page_size -1)) ABORT("Bad GET_MEM arg");
     result = mmap(last_addr, bytes, PROT_READ | PROT_WRITE | OPT_PROT_EXEC,
-		  GC_MMAP_FLAGS | OPT_MAP_ANON, zero_fd, 0/* offset */);
+      GC_MMAP_FLAGS | OPT_MAP_ANON, zero_fd, 0/* offset */);
     if (result == MAP_FAILED) return(0);
     last_addr = (ptr_t)result + bytes + GC_page_size - 1;
     last_addr = (ptr_t)((word)last_addr & ~(GC_page_size - 1));
 #   if !defined(LINUX)
       if (last_addr == 0) {
-        /* Oops.  We got the end of the address space.  This isn't	*/
-	/* usable by arbitrary C code, since one-past-end pointers	*/
-	/* don't work, so we discard it and try again.			*/
-	munmap(result, (size_t)(-GC_page_size) - (size_t)result);
-			/* Leave last page mapped, so we can't repeat. */
-	return GC_unix_get_mem(bytes);
+        /* Oops.  We got the end of the address space.  This isn't  */
+  /* usable by arbitrary C code, since one-past-end pointers  */
+  /* don't work, so we discard it and try again.      */
+  munmap(result, (size_t)(-GC_page_size) - (size_t)result);
+      /* Leave last page mapped, so we can't repeat. */
+  return GC_unix_get_mem(bytes);
       }
 #   else
       GC_ASSERT(last_addr != 0);
@@ -1618,14 +1618,14 @@
 {
   ptr_t result;
 # ifdef IRIX5
-    /* Bare sbrk isn't thread safe.  Play by malloc rules.	*/
-    /* The equivalent may be needed on other systems as well. 	*/
+    /* Bare sbrk isn't thread safe.  Play by malloc rules.  */
+    /* The equivalent may be needed on other systems as well.   */
     __LOCK_MALLOC();
 # endif
   {
     ptr_t cur_brk = (ptr_t)sbrk(0);
     SBRK_ARG_T lsbs = (word)cur_brk & (GC_page_size-1);
-    
+
     if ((SBRK_ARG_T)bytes < 0) return(0); /* too big */
     if (lsbs != 0) {
         if((ptr_t)sbrk(GC_page_size - lsbs) == (ptr_t)(-1)) return(0);
@@ -1651,9 +1651,9 @@
     void * result;
 
     if (DosAllocMem(&result, bytes, PAG_EXECUTE | PAG_READ |
-    				    PAG_WRITE | PAG_COMMIT)
-		    != NO_ERROR) {
-	return(0);
+                PAG_WRITE | PAG_COMMIT)
+        != NO_ERROR) {
+  return(0);
     }
     if (result == 0) return(os2_alloc(bytes));
     return(result);
@@ -1682,39 +1682,39 @@
     ptr_t result;
 
     if (GLOBAL_ALLOC_TEST) {
-    	/* VirtualAlloc doesn't like PAGE_EXECUTE_READWRITE.	*/
-    	/* There are also unconfirmed rumors of other		*/
-    	/* problems, so we dodge the issue.			*/
+      /* VirtualAlloc doesn't like PAGE_EXECUTE_READWRITE.  */
+      /* There are also unconfirmed rumors of other   */
+      /* problems, so we dodge the issue.     */
         result = (ptr_t) GlobalAlloc(0, bytes + HBLKSIZE);
         result = (ptr_t)(((word)result + HBLKSIZE) & ~(HBLKSIZE-1));
     } else {
-	/* VirtualProtect only works on regions returned by a	*/
-	/* single VirtualAlloc call.  Thus we allocate one 	*/
-	/* extra page, which will prevent merging of blocks	*/
-	/* in separate regions, and eliminate any temptation	*/
-	/* to call VirtualProtect on a range spanning regions.	*/
-	/* This wastes a small amount of memory, and risks	*/
-	/* increased fragmentation.  But better alternatives	*/
-	/* would require effort.				*/
+  /* VirtualProtect only works on regions returned by a */
+  /* single VirtualAlloc call.  Thus we allocate one  */
+  /* extra page, which will prevent merging of blocks */
+  /* in separate regions, and eliminate any temptation  */
+  /* to call VirtualProtect on a range spanning regions.  */
+  /* This wastes a small amount of memory, and risks  */
+  /* increased fragmentation.  But better alternatives  */
+  /* would require effort.        */
         result = (ptr_t) VirtualAlloc(NULL, bytes + 1,
-    				      MEM_COMMIT | MEM_RESERVE,
-    				      PAGE_EXECUTE_READWRITE);
+                  MEM_COMMIT | MEM_RESERVE,
+                  PAGE_EXECUTE_READWRITE);
     }
     if (HBLKDISPL(result) != 0) ABORT("Bad VirtualAlloc result");
-    	/* If I read the documentation correctly, this can	*/
-    	/* only happen if HBLKSIZE > 64k or not a power of 2.	*/
+      /* If I read the documentation correctly, this can  */
+      /* only happen if HBLKSIZE > 64k or not a power of 2. */
     if (GC_n_heap_bases >= MAX_HEAP_SECTS) ABORT("Too many heap sections");
     GC_heap_bases[GC_n_heap_bases++] = result;
-    return(result);			  
+    return(result);
 }
 
 void GC_win32_free_heap ()
 {
     if (GC_no_win32_dlls) {
- 	while (GC_n_heap_bases > 0) {
- 	    GlobalFree (GC_heap_bases[--GC_n_heap_bases]);
- 	    GC_heap_bases[GC_n_heap_bases] = 0;
- 	}
+  while (GC_n_heap_bases > 0) {
+      GlobalFree (GC_heap_bases[--GC_n_heap_bases]);
+      GC_heap_bases[GC_n_heap_bases] = 0;
+  }
     }
 }
 # endif
@@ -1740,53 +1740,53 @@
 
     /* Try to find reserved, uncommitted pages */
     for (i = 0; i < GC_n_heap_bases; i++) {
-	if (((word)(-(signed_word)GC_heap_lengths[i])
-	     & (GC_sysinfo.dwAllocationGranularity-1))
-	    >= bytes) {
-	    result = GC_heap_bases[i] + GC_heap_lengths[i];
-	    break;
-	}
+  if (((word)(-(signed_word)GC_heap_lengths[i])
+       & (GC_sysinfo.dwAllocationGranularity-1))
+      >= bytes) {
+      result = GC_heap_bases[i] + GC_heap_lengths[i];
+      break;
+  }
     }
 
     if (i == GC_n_heap_bases) {
-	/* Reserve more pages */
-	word res_bytes = (bytes + GC_sysinfo.dwAllocationGranularity-1)
-			 & ~(GC_sysinfo.dwAllocationGranularity-1);
-	/* If we ever support MPROTECT_VDB here, we will probably need to	*/
-	/* ensure that res_bytes is strictly > bytes, so that VirtualProtect	*/
-	/* never spans regions.  It seems to be OK for a VirtualFree argument	*/
-	/* to span regions, so we should be OK for now.				*/
-	result = (ptr_t) VirtualAlloc(NULL, res_bytes,
-    				      MEM_RESERVE | MEM_TOP_DOWN,
-    				      PAGE_EXECUTE_READWRITE);
-	if (HBLKDISPL(result) != 0) ABORT("Bad VirtualAlloc result");
-    	    /* If I read the documentation correctly, this can	*/
-    	    /* only happen if HBLKSIZE > 64k or not a power of 2.	*/
-	if (GC_n_heap_bases >= MAX_HEAP_SECTS) ABORT("Too many heap sections");
-	GC_heap_bases[GC_n_heap_bases] = result;
-	GC_heap_lengths[GC_n_heap_bases] = 0;
-	GC_n_heap_bases++;
+  /* Reserve more pages */
+  word res_bytes = (bytes + GC_sysinfo.dwAllocationGranularity-1)
+       & ~(GC_sysinfo.dwAllocationGranularity-1);
+  /* If we ever support MPROTECT_VDB here, we will probably need to */
+  /* ensure that res_bytes is strictly > bytes, so that VirtualProtect  */
+  /* never spans regions.  It seems to be OK for a VirtualFree argument */
+  /* to span regions, so we should be OK for now.       */
+  result = (ptr_t) VirtualAlloc(NULL, res_bytes,
+                  MEM_RESERVE | MEM_TOP_DOWN,
+                  PAGE_EXECUTE_READWRITE);
+  if (HBLKDISPL(result) != 0) ABORT("Bad VirtualAlloc result");
+          /* If I read the documentation correctly, this can  */
+          /* only happen if HBLKSIZE > 64k or not a power of 2. */
+  if (GC_n_heap_bases >= MAX_HEAP_SECTS) ABORT("Too many heap sections");
+  GC_heap_bases[GC_n_heap_bases] = result;
+  GC_heap_lengths[GC_n_heap_bases] = 0;
+  GC_n_heap_bases++;
     }
 
     /* Commit pages */
     result = (ptr_t) VirtualAlloc(result, bytes,
-				  MEM_COMMIT,
-    				  PAGE_EXECUTE_READWRITE);
+          MEM_COMMIT,
+              PAGE_EXECUTE_READWRITE);
     if (result != NULL) {
-	if (HBLKDISPL(result) != 0) ABORT("Bad VirtualAlloc result");
-	GC_heap_lengths[i] += bytes;
+  if (HBLKDISPL(result) != 0) ABORT("Bad VirtualAlloc result");
+  GC_heap_lengths[i] += bytes;
     }
 
-    return(result);			  
+    return(result);
 }
 # endif
 
 #ifdef USE_MUNMAP
 
-/* For now, this only works on Win32/WinCE and some Unix-like	*/
-/* systems.  If you have something else, don't define		*/
-/* USE_MUNMAP.							*/
-/* We assume ANSI C to support this feature.			*/
+/* For now, this only works on Win32/WinCE and some Unix-like */
+/* systems.  If you have something else, don't define   */
+/* USE_MUNMAP.              */
+/* We assume ANSI C to support this feature.      */
 
 #if !defined(MSWIN32) && !defined(MSWINCE)
 
@@ -1797,9 +1797,9 @@
 
 #endif
 
-/* Compute a page aligned starting address for the unmap 	*/
-/* operation on a block of size bytes starting at start.	*/
-/* Return 0 if the block is too small to make this feasible.	*/
+/* Compute a page aligned starting address for the unmap  */
+/* operation on a block of size bytes starting at start.  */
+/* Return 0 if the block is too small to make this feasible.  */
 ptr_t GC_unmap_start(ptr_t start, word bytes)
 {
     ptr_t result = start;
@@ -1810,8 +1810,8 @@
     return result;
 }
 
-/* Compute end address for an unmap operation on the indicated	*/
-/* block.							*/
+/* Compute end address for an unmap operation on the indicated  */
+/* block.             */
 ptr_t GC_unmap_end(ptr_t start, word bytes)
 {
     ptr_t end_addr = start + bytes;
@@ -1819,17 +1819,17 @@
     return end_addr;
 }
 
-/* Under Win32/WinCE we commit (map) and decommit (unmap)	*/
-/* memory using	VirtualAlloc and VirtualFree.  These functions	*/
-/* work on individual allocations of virtual memory, made	*/
-/* previously using VirtualAlloc with the MEM_RESERVE flag.	*/
-/* The ranges we need to (de)commit may span several of these	*/
-/* allocations; therefore we use VirtualQuery to check		*/
-/* allocation lengths, and split up the range as necessary.	*/
+/* Under Win32/WinCE we commit (map) and decommit (unmap) */
+/* memory using VirtualAlloc and VirtualFree.  These functions  */
+/* work on individual allocations of virtual memory, made */
+/* previously using VirtualAlloc with the MEM_RESERVE flag. */
+/* The ranges we need to (de)commit may span several of these */
+/* allocations; therefore we use VirtualQuery to check    */
+/* allocation lengths, and split up the range as necessary. */
 
-/* We assume that GC_remap is called on exactly the same range	*/
-/* as a previous call to GC_unmap.  It is safe to consistently	*/
-/* round the endpoints in both places.				*/
+/* We assume that GC_remap is called on exactly the same range  */
+/* as a previous call to GC_unmap.  It is safe to consistently  */
+/* round the endpoints in both places.        */
 void GC_unmap(ptr_t start, word bytes)
 {
     ptr_t start_addr = GC_unmap_start(start, bytes);
@@ -1839,25 +1839,25 @@
 #   if defined(MSWIN32) || defined(MSWINCE)
       while (len != 0) {
           MEMORY_BASIC_INFORMATION mem_info;
-	  GC_word free_len;
-	  if (VirtualQuery(start_addr, &mem_info, sizeof(mem_info))
-	      != sizeof(mem_info))
-	      ABORT("Weird VirtualQuery result");
-	  free_len = (len < mem_info.RegionSize) ? len : mem_info.RegionSize;
-	  if (!VirtualFree(start_addr, free_len, MEM_DECOMMIT))
-	      ABORT("VirtualFree failed");
-	  GC_unmapped_bytes += free_len;
-	  start_addr += free_len;
-	  len -= free_len;
+    GC_word free_len;
+    if (VirtualQuery(start_addr, &mem_info, sizeof(mem_info))
+        != sizeof(mem_info))
+        ABORT("Weird VirtualQuery result");
+    free_len = (len < mem_info.RegionSize) ? len : mem_info.RegionSize;
+    if (!VirtualFree(start_addr, free_len, MEM_DECOMMIT))
+        ABORT("VirtualFree failed");
+    GC_unmapped_bytes += free_len;
+    start_addr += free_len;
+    len -= free_len;
       }
 #   else
-      /* We immediately remap it to prevent an intervening mmap from	*/
-      /* accidentally grabbing the same address space.			*/
+      /* We immediately remap it to prevent an intervening mmap from  */
+      /* accidentally grabbing the same address space.      */
       {
-	void * result;
+  void * result;
         result = mmap(start_addr, len, PROT_NONE,
-		      MAP_PRIVATE | MAP_FIXED | OPT_MAP_ANON,
-		      zero_fd, 0/* offset */);
+          MAP_PRIVATE | MAP_FIXED | OPT_MAP_ANON,
+          zero_fd, 0/* offset */);
         if (result != (void *)start_addr) ABORT("mmap(...PROT_NONE...) failed");
       }
       GC_unmapped_bytes += len;
@@ -1877,42 +1877,42 @@
       if (0 == start_addr) return;
       while (len != 0) {
           MEMORY_BASIC_INFORMATION mem_info;
-	  GC_word alloc_len;
-	  if (VirtualQuery(start_addr, &mem_info, sizeof(mem_info))
-	      != sizeof(mem_info))
-	      ABORT("Weird VirtualQuery result");
-	  alloc_len = (len < mem_info.RegionSize) ? len : mem_info.RegionSize;
-	  result = VirtualAlloc(start_addr, alloc_len,
-				MEM_COMMIT,
-				PAGE_EXECUTE_READWRITE);
-	  if (result != start_addr) {
-	      ABORT("VirtualAlloc remapping failed");
-	  }
-	  GC_unmapped_bytes -= alloc_len;
-	  start_addr += alloc_len;
-	  len -= alloc_len;
+    GC_word alloc_len;
+    if (VirtualQuery(start_addr, &mem_info, sizeof(mem_info))
+        != sizeof(mem_info))
+        ABORT("Weird VirtualQuery result");
+    alloc_len = (len < mem_info.RegionSize) ? len : mem_info.RegionSize;
+    result = VirtualAlloc(start_addr, alloc_len,
+        MEM_COMMIT,
+        PAGE_EXECUTE_READWRITE);
+    if (result != start_addr) {
+        ABORT("VirtualAlloc remapping failed");
+    }
+    GC_unmapped_bytes -= alloc_len;
+    start_addr += alloc_len;
+    len -= alloc_len;
       }
 #   else
       /* It was already remapped with PROT_NONE. */
-      int result; 
+      int result;
 
       if (0 == start_addr) return;
       result = mprotect(start_addr, len,
-		        PROT_READ | PROT_WRITE | OPT_PROT_EXEC);
+            PROT_READ | PROT_WRITE | OPT_PROT_EXEC);
       if (result != 0) {
-	  GC_err_printf3(
-		"Mprotect failed at 0x%lx (length %ld) with errno %ld\n",
-	        start_addr, len, errno);
-	  ABORT("Mprotect remapping failed");
+    GC_err_printf3(
+    "Mprotect failed at 0x%lx (length %ld) with errno %ld\n",
+          start_addr, len, errno);
+    ABORT("Mprotect remapping failed");
       }
       GC_unmapped_bytes -= len;
 #   endif
 }
 
-/* Two adjacent blocks have already been unmapped and are about to	*/
-/* be merged.  Unmap the whole block.  This typically requires		*/
-/* that we unmap a small section in the middle that was not previously	*/
-/* unmapped due to alignment constraints.				*/
+/* Two adjacent blocks have already been unmapped and are about to  */
+/* be merged.  Unmap the whole block.  This typically requires    */
+/* that we unmap a small section in the middle that was not previously  */
+/* unmapped due to alignment constraints.       */
 void GC_unmap_gap(ptr_t start1, word bytes1, ptr_t start2, word bytes2)
 {
     ptr_t start1_addr = GC_unmap_start(start1, bytes1);
@@ -1930,16 +1930,16 @@
 #   if defined(MSWIN32) || defined(MSWINCE)
       while (len != 0) {
           MEMORY_BASIC_INFORMATION mem_info;
-	  GC_word free_len;
-	  if (VirtualQuery(start_addr, &mem_info, sizeof(mem_info))
-	      != sizeof(mem_info))
-	      ABORT("Weird VirtualQuery result");
-	  free_len = (len < mem_info.RegionSize) ? len : mem_info.RegionSize;
-	  if (!VirtualFree(start_addr, free_len, MEM_DECOMMIT))
-	      ABORT("VirtualFree failed");
-	  GC_unmapped_bytes += free_len;
-	  start_addr += free_len;
-	  len -= free_len;
+    GC_word free_len;
+    if (VirtualQuery(start_addr, &mem_info, sizeof(mem_info))
+        != sizeof(mem_info))
+        ABORT("Weird VirtualQuery result");
+    free_len = (len < mem_info.RegionSize) ? len : mem_info.RegionSize;
+    if (!VirtualFree(start_addr, free_len, MEM_DECOMMIT))
+        ABORT("VirtualFree failed");
+    GC_unmapped_bytes += free_len;
+    start_addr += free_len;
+    len -= free_len;
       }
 #   else
       if (len != 0 && munmap(start_addr, len) != 0) ABORT("munmap failed");
@@ -1949,9 +1949,9 @@
 
 #endif /* USE_MUNMAP */
 
-/* Routine for pushing any additional roots.  In THREADS 	*/
-/* environment, this is also responsible for marking from 	*/
-/* thread stacks. 						*/
+/* Routine for pushing any additional roots.  In THREADS  */
+/* environment, this is also responsible for marking from   */
+/* thread stacks.             */
 #ifndef THREADS
 void (*GC_push_other_roots)() = 0;
 #else /* THREADS */
@@ -1961,16 +1961,16 @@
 {
     struct PCR_ThCtl_TInfoRep info;
     PCR_ERes result;
-    
+
     info.ti_stkLow = info.ti_stkHi = 0;
     result = PCR_ThCtl_GetInfo(t, &info);
     GC_push_all_stack((ptr_t)(info.ti_stkLow), (ptr_t)(info.ti_stkHi));
     return(result);
 }
 
-/* Push the contents of an old object. We treat this as stack	*/
-/* data only becasue that makes it robust against mark stack	*/
-/* overflow.							*/
+/* Push the contents of an old object. We treat this as stack */
+/* data only becasue that makes it robust against mark stack  */
+/* overflow.              */
 PCR_ERes GC_push_old_obj(void *p, size_t size, PCR_Any data)
 {
     GC_push_all_stack((ptr_t)p, (ptr_t)p + size);
@@ -1980,22 +1980,22 @@
 
 void GC_default_push_other_roots GC_PROTO((void))
 {
-    /* Traverse data allocated by previous memory managers.		*/
-	{
-	  extern struct PCR_MM_ProcsRep * GC_old_allocator;
-	  
-	  if ((*(GC_old_allocator->mmp_enumerate))(PCR_Bool_false,
-	  					   GC_push_old_obj, 0)
-	      != PCR_ERes_okay) {
-	      ABORT("Old object enumeration failed");
-	  }
-	}
+    /* Traverse data allocated by previous memory managers.   */
+  {
+    extern struct PCR_MM_ProcsRep * GC_old_allocator;
+
+    if ((*(GC_old_allocator->mmp_enumerate))(PCR_Bool_false,
+                 GC_push_old_obj, 0)
+        != PCR_ERes_okay) {
+        ABORT("Old object enumeration failed");
+    }
+  }
     /* Traverse all thread stacks. */
-	if (PCR_ERes_IsErr(
+  if (PCR_ERes_IsErr(
                 PCR_ThCtl_ApplyToAllOtherThreads(GC_push_thread_stack,0))
               || PCR_ERes_IsErr(GC_push_thread_stack(PCR_Th_CurrThread(), 0))) {
               ABORT("Thread stack marking failed\n");
-	}
+  }
 }
 
 # endif /* PCR */
@@ -2026,7 +2026,7 @@
 int dummy3;
 {
     word q = *p;
-    
+
     GC_PUSH_ONE_STACK(q, p);
 }
 
@@ -2036,15 +2036,15 @@
 
 void GC_default_push_other_roots GC_PROTO((void))
 {
-    /* Use the M3 provided routine for finding static roots.	 */
-    /* This is a bit dubious, since it presumes no C roots.	 */
+    /* Use the M3 provided routine for finding static roots.   */
+    /* This is a bit dubious, since it presumes no C roots.  */
     /* We handle the collector roots explicitly in GC_push_roots */
-      	RTMain__GlobalMapProc(GC_m3_push_root, 0, GC_TracedRefTypes);
-	if (GC_words_allocd > 0) {
-	    ThreadF__ProcessStacks(GC_push_thread_stack);
-	}
-	/* Otherwise this isn't absolutely necessary, and we have	*/
-	/* startup ordering problems.					*/
+        RTMain__GlobalMapProc(GC_m3_push_root, 0, GC_TracedRefTypes);
+  if (GC_words_allocd > 0) {
+      ThreadF__ProcessStacks(GC_push_thread_stack);
+  }
+  /* Otherwise this isn't absolutely necessary, and we have */
+  /* startup ordering problems.         */
 }
 
 # endif /* SRC_M3 */
@@ -2068,34 +2068,34 @@
 /*
  * Routines for accessing dirty  bits on virtual pages.
  * We plan to eventually implement four strategies for doing so:
- * DEFAULT_VDB:	A simple dummy implementation that treats every page
- *		as possibly dirty.  This makes incremental collection
- *		useless, but the implementation is still correct.
- * PCR_VDB:	Use PPCRs virtual dirty bit facility.
- * PROC_VDB:	Use the /proc facility for reading dirty bits.  Only
- *		works under some SVR4 variants.  Even then, it may be
- *		too slow to be entirely satisfactory.  Requires reading
- *		dirty bits for entire address space.  Implementations tend
- *		to assume that the client is a (slow) debugger.
+ * DEFAULT_VDB: A simple dummy implementation that treats every page
+ *    as possibly dirty.  This makes incremental collection
+ *    useless, but the implementation is still correct.
+ * PCR_VDB: Use PPCRs virtual dirty bit facility.
+ * PROC_VDB:  Use the /proc facility for reading dirty bits.  Only
+ *    works under some SVR4 variants.  Even then, it may be
+ *    too slow to be entirely satisfactory.  Requires reading
+ *    dirty bits for entire address space.  Implementations tend
+ *    to assume that the client is a (slow) debugger.
  * MPROTECT_VDB:Protect pages and then catch the faults to keep track of
- *		dirtied pages.  The implementation (and implementability)
- *		is highly system dependent.  This usually fails when system
- *		calls write to a protected page.  We prevent the read system
- *		call from doing so.  It is the clients responsibility to
- *		make sure that other system calls are similarly protected
- *		or write only to the stack.
+ *    dirtied pages.  The implementation (and implementability)
+ *    is highly system dependent.  This usually fails when system
+ *    calls write to a protected page.  We prevent the read system
+ *    call from doing so.  It is the clients responsibility to
+ *    make sure that other system calls are similarly protected
+ *    or write only to the stack.
  */
 GC_bool GC_dirty_maintained = FALSE;
 
 # ifdef DEFAULT_VDB
 
-/* All of the following assume the allocation lock is held, and	*/
-/* signals are disabled.					*/
+/* All of the following assume the allocation lock is held, and */
+/* signals are disabled.          */
 
-/* The client asserts that unallocated pages in the heap are never	*/
-/* written.								*/
+/* The client asserts that unallocated pages in the heap are never  */
+/* written.               */
 
-/* Initialize virtual dirty bit implementation.			*/
+/* Initialize virtual dirty bit implementation.     */
 void GC_dirty_init()
 {
 #   ifdef PRINTSTATS
@@ -2104,15 +2104,15 @@
     GC_dirty_maintained = TRUE;
 }
 
-/* Retrieve system dirty bits for heap to a local buffer.	*/
-/* Restore the systems notion of which pages are dirty.		*/
+/* Retrieve system dirty bits for heap to a local buffer. */
+/* Restore the systems notion of which pages are dirty.   */
 void GC_read_dirty()
 {}
 
-/* Is the HBLKSIZE sized page at h marked dirty in the local buffer?	*/
-/* If the actual page size is different, this returns TRUE if any	*/
-/* of the pages overlapping h are dirty.  This routine may err on the	*/
-/* side of labelling pages as dirty (and this implementation does).	*/
+/* Is the HBLKSIZE sized page at h marked dirty in the local buffer?  */
+/* If the actual page size is different, this returns TRUE if any */
+/* of the pages overlapping h are dirty.  This routine may err on the */
+/* side of labelling pages as dirty (and this implementation does). */
 /*ARGSUSED*/
 GC_bool GC_page_was_dirty(h)
 struct hblk *h;
@@ -2126,8 +2126,8 @@
  * stacks, e.g. under Solaris 2.X.  Otherwise the following default
  * versions are adequate.
  */
- 
-/* Could any valid GC heap pointer ever have been written to this page?	*/
+
+/* Could any valid GC heap pointer ever have been written to this page? */
 /*ARGSUSED*/
 GC_bool GC_page_was_ever_dirty(h)
 struct hblk *h;
@@ -2135,20 +2135,20 @@
     return(TRUE);
 }
 
-/* Reset the n pages starting at h to "was never dirty" status.	*/
+/* Reset the n pages starting at h to "was never dirty" status. */
 void GC_is_fresh(h, n)
 struct hblk *h;
 word n;
 {
 }
 
-/* A call that:						*/
-/* I) hints that [h, h+nblocks) is about to be written.	*/
-/* II) guarantees that protection is removed.		*/
-/* (I) may speed up some dirty bit implementations.	*/
-/* (II) may be essential if we need to ensure that	*/
-/* pointer-free system call buffers in the heap are 	*/
-/* not protected.					*/
+/* A call that:           */
+/* I) hints that [h, h+nblocks) is about to be written. */
+/* II) guarantees that protection is removed.   */
+/* (I) may speed up some dirty bit implementations. */
+/* (II) may be essential if we need to ensure that  */
+/* pointer-free system call buffers in the heap are   */
+/* not protected.         */
 /*ARGSUSED*/
 void GC_remove_protection(h, nblocks, is_ptrfree)
 struct hblk *h;
@@ -2177,7 +2177,7 @@
  * are not protected.  Another alternative is to wrap system calls
  * (see example for read below), but the current implementation holds
  * a lock across blocking calls, making it problematic for multithreaded
- * applications. 
+ * applications.
  * We assume the page size is a multiple of HBLKSIZE.
  * We prefer them to be the same.  We avoid protecting POINTERFREE
  * objects only if they are the same.
@@ -2190,16 +2190,16 @@
 #   include <sys/syscall.h>
 
 #   define PROTECT(addr, len) \
-    	  if (mprotect((caddr_t)(addr), (size_t)(len), \
-    	      	       PROT_READ | OPT_PROT_EXEC) < 0) { \
-    	    ABORT("mprotect failed"); \
-    	  }
+        if (mprotect((caddr_t)(addr), (size_t)(len), \
+                     PROT_READ | OPT_PROT_EXEC) < 0) { \
+          ABORT("mprotect failed"); \
+        }
 #   define UNPROTECT(addr, len) \
-    	  if (mprotect((caddr_t)(addr), (size_t)(len), \
-    	  	       PROT_WRITE | PROT_READ | OPT_PROT_EXEC ) < 0) { \
-    	    ABORT("un-mprotect failed"); \
-    	  }
-    	  
+        if (mprotect((caddr_t)(addr), (size_t)(len), \
+                 PROT_WRITE | PROT_READ | OPT_PROT_EXEC ) < 0) { \
+          ABORT("un-mprotect failed"); \
+        }
+
 # else
 
 # ifdef DARWIN
@@ -2218,24 +2218,24 @@
             ABORT("vm_portect failed"); \
         }
 # else
-    
+
 #   ifndef MSWINCE
 #     include <signal.h>
 #   endif
 
     static DWORD protect_junk;
 #   define PROTECT(addr, len) \
-	  if (!VirtualProtect((addr), (len), PAGE_EXECUTE_READ, \
-	  		      &protect_junk)) { \
-	    DWORD last_error = GetLastError(); \
-	    GC_printf1("Last error code: %lx\n", last_error); \
-	    ABORT("VirtualProtect failed"); \
-	  }
+    if (!VirtualProtect((addr), (len), PAGE_EXECUTE_READ, \
+              &protect_junk)) { \
+      DWORD last_error = GetLastError(); \
+      GC_printf1("Last error code: %lx\n", last_error); \
+      ABORT("VirtualProtect failed"); \
+    }
 #   define UNPROTECT(addr, len) \
-	  if (!VirtualProtect((addr), (len), PAGE_EXECUTE_READWRITE, \
-	  		      &protect_junk)) { \
-	    ABORT("un-VirtualProtect failed"); \
-	  }
+    if (!VirtualProtect((addr), (len), PAGE_EXECUTE_READWRITE, \
+              &protect_junk)) { \
+      ABORT("un-VirtualProtect failed"); \
+    }
 # endif /* !DARWIN */
 # endif /* MSWIN32 || MSWINCE || DARWIN */
 
@@ -2296,79 +2296,79 @@
 #   else
 #     if defined(IA64) || defined(HP_PA) || defined(X86_64)
         typedef void (* REAL_SIG_PF)(int, siginfo_t *, s_c *);
-	/* FIXME:						  */
-	/* According to SUSV3, the last argument should have type */
-	/* void * or ucontext_t *				  */
+  /* FIXME:             */
+  /* According to SUSV3, the last argument should have type */
+  /* void * or ucontext_t *         */
 #     else
         typedef void (* REAL_SIG_PF)(int, s_c);
 #     endif
 #   endif
 #   ifdef ALPHA
-    /* Retrieve fault address from sigcontext structure by decoding	*/
-    /* instruction.							*/
+    /* Retrieve fault address from sigcontext structure by decoding */
+    /* instruction.             */
     char * get_fault_addr(s_c *sc) {
         unsigned instr;
-	word faultaddr;
+  word faultaddr;
 
-	instr = *((unsigned *)(sc->sc_pc));
-	faultaddr = sc->sc_regs[(instr >> 16) & 0x1f];
-	faultaddr += (word) (((int)instr << 16) >> 16);
-	return (char *)faultaddr;
+  instr = *((unsigned *)(sc->sc_pc));
+  faultaddr = sc->sc_regs[(instr >> 16) & 0x1f];
+  faultaddr += (word) (((int)instr << 16) >> 16);
+  return (char *)faultaddr;
     }
 #   endif /* !ALPHA */
 # endif /* LINUX */
 
 #ifndef DARWIN
 SIG_PF GC_old_bus_handler;
-SIG_PF GC_old_segv_handler;	/* Also old MSWIN32 ACCESS_VIOLATION filter */
+SIG_PF GC_old_segv_handler; /* Also old MSWIN32 ACCESS_VIOLATION filter */
 #endif /* !DARWIN */
 
 #if defined(THREADS)
-/* We need to lock around the bitmap update in the write fault handler	*/
-/* in order to avoid the risk of losing a bit.  We do this with a 	*/
-/* test-and-set spin lock if we know how to do that.  Otherwise we	*/
-/* check whether we are already in the handler and use the dumb but	*/
-/* safe fallback algorithm of setting all bits in the word.		*/
-/* Contention should be very rare, so we do the minimum to handle it	*/
-/* correctly.								*/
+/* We need to lock around the bitmap update in the write fault handler  */
+/* in order to avoid the risk of losing a bit.  We do this with a   */
+/* test-and-set spin lock if we know how to do that.  Otherwise we  */
+/* check whether we are already in the handler and use the dumb but */
+/* safe fallback algorithm of setting all bits in the word.   */
+/* Contention should be very rare, so we do the minimum to handle it  */
+/* correctly.               */
 #ifdef GC_TEST_AND_SET_DEFINED
   static VOLATILE unsigned int fault_handler_lock = 0;
   void async_set_pht_entry_from_index(VOLATILE page_hash_table db, int index) {
     while (GC_test_and_set(&fault_handler_lock)) {}
-    /* Could also revert to set_pht_entry_from_index_safe if initial	*/
-    /* GC_test_and_set fails.						*/
+    /* Could also revert to set_pht_entry_from_index_safe if initial  */
+    /* GC_test_and_set fails.           */
     set_pht_entry_from_index(db, index);
     GC_clear(&fault_handler_lock);
   }
 #else /* !GC_TEST_AND_SET_DEFINED */
-  /* THIS IS INCORRECT! The dirty bit vector may be temporarily wrong,	*/
+  /* THIS IS INCORRECT! The dirty bit vector may be temporarily wrong,  */
   /* just before we notice the conflict and correct it. We may end up   */
-  /* looking at it while it's wrong.  But this requires contention	*/
-  /* exactly when a GC is triggered, which seems far less likely to	*/
-  /* fail than the old code, which had no reported failures.  Thus we	*/
-  /* leave it this way while we think of something better, or support	*/
-  /* GC_test_and_set on the remaining platforms.			*/
+  /* looking at it while it's wrong.  But this requires contention  */
+  /* exactly when a GC is triggered, which seems far less likely to */
+  /* fail than the old code, which had no reported failures.  Thus we */
+  /* leave it this way while we think of something better, or support */
+  /* GC_test_and_set on the remaining platforms.      */
   static VOLATILE word currently_updating = 0;
   void async_set_pht_entry_from_index(VOLATILE page_hash_table db, int index) {
     unsigned int update_dummy;
     currently_updating = (word)(&update_dummy);
     set_pht_entry_from_index(db, index);
-    /* If we get contention in the 10 or so instruction window here,	*/
-    /* and we get stopped by a GC between the two updates, we lose!	*/
+    /* If we get contention in the 10 or so instruction window here,  */
+    /* and we get stopped by a GC between the two updates, we lose! */
     if (currently_updating != (word)(&update_dummy)) {
-	set_pht_entry_from_index_safe(db, index);
-	/* We claim that if two threads concurrently try to update the	*/
-	/* dirty bit vector, the first one to execute UPDATE_START 	*/
-	/* will see it changed when UPDATE_END is executed.  (Note that	*/
-	/* &update_dummy must differ in two distinct threads.)  It	*/
-	/* will then execute set_pht_entry_from_index_safe, thus 	*/
-	/* returning us to a safe state, though not soon enough.	*/
+  set_pht_entry_from_index_safe(db, index);
+  /* We claim that if two threads concurrently try to update the  */
+  /* dirty bit vector, the first one to execute UPDATE_START  */
+  /* will see it changed when UPDATE_END is executed.  (Note that */
+  /* &update_dummy must differ in two distinct threads.)  It  */
+  /* will then execute set_pht_entry_from_index_safe, thus  */
+  /* returning us to a safe state, though not soon enough.  */
     }
   }
 #endif /* !GC_TEST_AND_SET_DEFINED */
 #else /* !THREADS */
 # define async_set_pht_entry_from_index(db, index) \
-	set_pht_entry_from_index(db, index)
+  set_pht_entry_from_index(db, index)
 #endif /* !THREADS */
 
 /*ARGSUSED*/
@@ -2381,8 +2381,8 @@
 #   ifdef SUNOS4
 #     define SIG_OK (sig == SIGSEGV || sig == SIGBUS)
 #     define CODE_OK (FC_CODE(code) == FC_PROT \
-              	    || (FC_CODE(code) == FC_OBJERR \
-              	       && FC_ERRNO(code) == FC_PROT))
+                    || (FC_CODE(code) == FC_OBJERR \
+                       && FC_ERRNO(code) == FC_PROT))
 #   endif
 #   ifdef FREEBSD
 #     define SIG_OK (sig == SIGBUS)
@@ -2402,7 +2402,7 @@
 #     define CODE_OK (code == EACCES)
 #   endif
 #   ifdef HURD
-#     define SIG_OK (sig == SIGBUS || sig == SIGSEGV) 	
+#     define SIG_OK (sig == SIGBUS || sig == SIGSEGV)
 #     define CODE_OK  TRUE
 #   endif
 # endif /* IRIX5 || OSF1 || HURD */
@@ -2423,9 +2423,9 @@
 #   endif
 #   define SIG_OK (sig == SIGSEGV)
 #   define CODE_OK TRUE
-	/* Empirically c.trapno == 14, on IA32, but is that useful?     */
-	/* Should probably consider alignment issues on other 		*/
-	/* architectures.						*/
+  /* Empirically c.trapno == 14, on IA32, but is that useful?     */
+  /* Should probably consider alignment issues on other     */
+  /* architectures.           */
 # endif /* LINUX */
 
 # if defined(SUNOS5SIGS)
@@ -2440,10 +2440,10 @@
 #   ifdef HPUX
 #     define SIG_OK (sig == SIGSEGV || sig == SIGBUS)
 #     define CODE_OK (scp -> si_code == SEGV_ACCERR) \
-		     || (scp -> si_code == BUS_ADRERR) \
-		     || (scp -> si_code == BUS_UNKNOWN) \
-		     || (scp -> si_code == SEGV_UNKNOWN) \
-		     || (scp -> si_code == BUS_OBJERR)
+         || (scp -> si_code == BUS_ADRERR) \
+         || (scp -> si_code == BUS_UNKNOWN) \
+         || (scp -> si_code == SEGV_UNKNOWN) \
+         || (scp -> si_code == BUS_OBJERR)
 #   else
 #     ifdef FREEBSD
 #       define SIG_OK (sig == SIGBUS)
@@ -2452,196 +2452,196 @@
 #       define SIG_OK (sig == SIGSEGV)
 #       define CODE_OK (scp -> si_code == SEGV_ACCERR)
 #     endif
-#   endif    
+#   endif
 # endif /* SUNOS5SIGS */
 
 # if defined(MSWIN32) || defined(MSWINCE)
     LONG WINAPI GC_write_fault_handler(struct _EXCEPTION_POINTERS *exc_info)
 #   define SIG_OK (exc_info -> ExceptionRecord -> ExceptionCode == \
-			STATUS_ACCESS_VIOLATION)
+      STATUS_ACCESS_VIOLATION)
 #   define CODE_OK (exc_info -> ExceptionRecord -> ExceptionInformation[0] == 1)
-			/* Write fault */
+      /* Write fault */
 # endif /* MSWIN32 || MSWINCE */
 {
     register unsigned i;
-#   if defined(HURD) 
-	char *addr = (char *) code;
+#   if defined(HURD)
+  char *addr = (char *) code;
 #   endif
 #   ifdef IRIX5
-	char * addr = (char *) (size_t) (scp -> sc_badvaddr);
+  char * addr = (char *) (size_t) (scp -> sc_badvaddr);
 #   endif
 #   if defined(OSF1) && defined(ALPHA)
-	char * addr = (char *) (scp -> sc_traparg_a0);
+  char * addr = (char *) (scp -> sc_traparg_a0);
 #   endif
 #   ifdef SUNOS5SIGS
-	char * addr = (char *) (scp -> si_addr);
+  char * addr = (char *) (scp -> si_addr);
 #   endif
 #   ifdef LINUX
 #     if defined(I386)
-	char * addr = (char *) (sc.cr2);
+  char * addr = (char *) (sc.cr2);
 #     else
-#	if defined(M68K)
+# if defined(M68K)
           char * addr = NULL;
 
-	  struct sigcontext *scp = (struct sigcontext *)(sc);
+    struct sigcontext *scp = (struct sigcontext *)(sc);
 
-	  int format = (scp->sc_formatvec >> 12) & 0xf;
-	  unsigned long *framedata = (unsigned long *)(scp + 1); 
-	  unsigned long ea;
+    int format = (scp->sc_formatvec >> 12) & 0xf;
+    unsigned long *framedata = (unsigned long *)(scp + 1);
+    unsigned long ea;
 
-	  if (format == 0xa || format == 0xb) {
-	  	/* 68020/030 */
-	  	ea = framedata[2];
-	  } else if (format == 7) {
-	  	/* 68040 */
-	  	ea = framedata[3];
-	  	if (framedata[1] & 0x08000000) {
-	  		/* correct addr on misaligned access */
-	  		ea = (ea+4095)&(~4095);
-		}
-	  } else if (format == 4) {
-	  	/* 68060 */
-	  	ea = framedata[0];
-	  	if (framedata[1] & 0x08000000) {
-	  		/* correct addr on misaligned access */
-	  		ea = (ea+4095)&(~4095);
-	  	}
-	  }	
-	  addr = (char *)ea;
-#	else
-#	  ifdef ALPHA
+    if (format == 0xa || format == 0xb) {
+      /* 68020/030 */
+      ea = framedata[2];
+    } else if (format == 7) {
+      /* 68040 */
+      ea = framedata[3];
+      if (framedata[1] & 0x08000000) {
+        /* correct addr on misaligned access */
+        ea = (ea+4095)&(~4095);
+    }
+    } else if (format == 4) {
+      /* 68060 */
+      ea = framedata[0];
+      if (framedata[1] & 0x08000000) {
+        /* correct addr on misaligned access */
+        ea = (ea+4095)&(~4095);
+      }
+    }
+    addr = (char *)ea;
+# else
+#   ifdef ALPHA
             char * addr = get_fault_addr(sc);
-#	  else
-#	    if defined(IA64) || defined(HP_PA) || defined(X86_64)
-	      char * addr = si -> si_addr;
-	      /* I believe this is claimed to work on all platforms for	*/
-	      /* Linux 2.3.47 and later.  Hopefully we don't have to	*/
-	      /* worry about earlier kernels on IA64.			*/
-#	    else
+#   else
+#     if defined(IA64) || defined(HP_PA) || defined(X86_64)
+        char * addr = si -> si_addr;
+        /* I believe this is claimed to work on all platforms for */
+        /* Linux 2.3.47 and later.  Hopefully we don't have to  */
+        /* worry about earlier kernels on IA64.     */
+#     else
 #             if defined(POWERPC)
                 char * addr = (char *) (sc.regs->dar);
-#	      else
+#       else
 #               if defined(ARM32)
                   char * addr = (char *)sc.fault_address;
 #               else
-#		  if defined(CRIS)
-		    char * addr = (char *)sc.regs.csraddr;
-#		  else
-		    --> architecture not supported
-#		  endif
+#     if defined(CRIS)
+        char * addr = (char *)sc.regs.csraddr;
+#     else
+        --> architecture not supported
+#     endif
 #               endif
-#	      endif
-#	    endif
-#	  endif
-#	endif
+#       endif
 #     endif
 #   endif
+# endif
+#     endif
+#   endif
 #   if defined(MSWIN32) || defined(MSWINCE)
-	char * addr = (char *) (exc_info -> ExceptionRecord
-				-> ExceptionInformation[1]);
-#	define sig SIGSEGV
+  char * addr = (char *) (exc_info -> ExceptionRecord
+        -> ExceptionInformation[1]);
+# define sig SIGSEGV
 #   endif
-    
+
     if (SIG_OK && CODE_OK) {
         register struct hblk * h =
-        		(struct hblk *)((word)addr & ~(GC_page_size-1));
+            (struct hblk *)((word)addr & ~(GC_page_size-1));
         GC_bool in_allocd_block;
-        
-#	ifdef SUNOS5SIGS
-	    /* Address is only within the correct physical page.	*/
-	    in_allocd_block = FALSE;
+
+# ifdef SUNOS5SIGS
+      /* Address is only within the correct physical page.  */
+      in_allocd_block = FALSE;
             for (i = 0; i < divHBLKSZ(GC_page_size); i++) {
               if (HDR(h+i) != 0) {
                 in_allocd_block = TRUE;
               }
             }
-#	else
-	    in_allocd_block = (HDR(addr) != 0);
-#	endif
+# else
+      in_allocd_block = (HDR(addr) != 0);
+# endif
         if (!in_allocd_block) {
-	    /* FIXME - We should make sure that we invoke the	*/
-	    /* old handler with the appropriate calling 	*/
-	    /* sequence, which often depends on SA_SIGINFO.	*/
+      /* FIXME - We should make sure that we invoke the */
+      /* old handler with the appropriate calling   */
+      /* sequence, which often depends on SA_SIGINFO. */
 
-	    /* Heap blocks now begin and end on page boundaries */
+      /* Heap blocks now begin and end on page boundaries */
             SIG_PF old_handler;
-            
+
             if (sig == SIGSEGV) {
-            	old_handler = GC_old_segv_handler;
+              old_handler = GC_old_segv_handler;
             } else {
                 old_handler = GC_old_bus_handler;
             }
             if (old_handler == SIG_DFL) {
-#		if !defined(MSWIN32) && !defined(MSWINCE)
-		    GC_err_printf1("Segfault at 0x%lx\n", addr);
+#   if !defined(MSWIN32) && !defined(MSWINCE)
+        GC_err_printf1("Segfault at 0x%lx\n", addr);
                     ABORT("Unexpected bus error or segmentation fault");
-#		else
-		    return(EXCEPTION_CONTINUE_SEARCH);
-#		endif
+#   else
+        return(EXCEPTION_CONTINUE_SEARCH);
+#   endif
             } else {
-#		if defined (SUNOS4) \
+#   if defined (SUNOS4) \
                     || (defined(FREEBSD) && !defined(SUNOS5SIGS))
-		    (*old_handler) (sig, code, scp, addr);
-		    return;
-#		endif
-#		if defined (SUNOS5SIGS)
+        (*old_handler) (sig, code, scp, addr);
+        return;
+#   endif
+#   if defined (SUNOS5SIGS)
                     /*
-                     * FIXME: For FreeBSD, this code should check if the 
+                     * FIXME: For FreeBSD, this code should check if the
                      * old signal handler used the traditional BSD style and
                      * if so call it using that style.
                      */
-		    (*(REAL_SIG_PF)old_handler) (sig, scp, context);
-		    return;
-#		endif
-#		if defined (LINUX)
-#		    if defined(ALPHA) || defined(M68K)
-		        (*(REAL_SIG_PF)old_handler) (sig, code, sc);
-#		    else 
-#		      if defined(IA64) || defined(HP_PA) || defined(X86_64)
-		        (*(REAL_SIG_PF)old_handler) (sig, si, scp);
-#		      else
-		        (*(REAL_SIG_PF)old_handler) (sig, sc);
-#		      endif
-#		    endif
-		    return;
-#		endif
-#		if defined (IRIX5) || defined(OSF1) || defined(HURD)
-		    (*(REAL_SIG_PF)old_handler) (sig, code, scp);
-		    return;
-#		endif
-#		ifdef MSWIN32
-		    return((*old_handler)(exc_info));
-#		endif
+        (*(REAL_SIG_PF)old_handler) (sig, scp, context);
+        return;
+#   endif
+#   if defined (LINUX)
+#       if defined(ALPHA) || defined(M68K)
+            (*(REAL_SIG_PF)old_handler) (sig, code, sc);
+#       else
+#         if defined(IA64) || defined(HP_PA) || defined(X86_64)
+            (*(REAL_SIG_PF)old_handler) (sig, si, scp);
+#         else
+            (*(REAL_SIG_PF)old_handler) (sig, sc);
+#         endif
+#       endif
+        return;
+#   endif
+#   if defined (IRIX5) || defined(OSF1) || defined(HURD)
+        (*(REAL_SIG_PF)old_handler) (sig, code, scp);
+        return;
+#   endif
+#   ifdef MSWIN32
+        return((*old_handler)(exc_info));
+#   endif
             }
         }
         UNPROTECT(h, GC_page_size);
-	/* We need to make sure that no collection occurs between	*/
-	/* the UNPROTECT and the setting of the dirty bit.  Otherwise	*/
-	/* a write by a third thread might go unnoticed.  Reversing	*/
-	/* the order is just as bad, since we would end up unprotecting	*/
-	/* a page in a GC cycle during which it's not marked.		*/
-	/* Currently we do this by disabling the thread stopping	*/
-	/* signals while this handler is running.  An alternative might	*/
-	/* be to record the fact that we're about to unprotect, or	*/
-	/* have just unprotected a page in the GC's thread structure,	*/
-	/* and then to have the thread stopping code set the dirty	*/
-	/* flag, if necessary.						*/
+  /* We need to make sure that no collection occurs between */
+  /* the UNPROTECT and the setting of the dirty bit.  Otherwise */
+  /* a write by a third thread might go unnoticed.  Reversing */
+  /* the order is just as bad, since we would end up unprotecting */
+  /* a page in a GC cycle during which it's not marked.   */
+  /* Currently we do this by disabling the thread stopping  */
+  /* signals while this handler is running.  An alternative might */
+  /* be to record the fact that we're about to unprotect, or  */
+  /* have just unprotected a page in the GC's thread structure, */
+  /* and then to have the thread stopping code set the dirty  */
+  /* flag, if necessary.            */
         for (i = 0; i < divHBLKSZ(GC_page_size); i++) {
             register int index = PHT_HASH(h+i);
-            
+
             async_set_pht_entry_from_index(GC_dirty_pages, index);
         }
-#	if defined(OSF1)
-	    /* These reset the signal handler each time by default. */
-	    signal(SIGSEGV, (SIG_PF) GC_write_fault_handler);
-#	endif
-    	/* The write may not take place before dirty bits are read.	*/
-    	/* But then we'll fault again ...				*/
-#	if defined(MSWIN32) || defined(MSWINCE)
-	    return(EXCEPTION_CONTINUE_EXECUTION);
-#	else
-	    return;
-#	endif
+# if defined(OSF1)
+      /* These reset the signal handler each time by default. */
+      signal(SIGSEGV, (SIG_PF) GC_write_fault_handler);
+# endif
+      /* The write may not take place before dirty bits are read. */
+      /* But then we'll fault again ...       */
+# if defined(MSWIN32) || defined(MSWINCE)
+      return(EXCEPTION_CONTINUE_EXECUTION);
+# else
+      return;
+# endif
     }
 #if defined(MSWIN32) || defined(MSWINCE)
     return EXCEPTION_CONTINUE_SEARCH;
@@ -2667,15 +2667,15 @@
     struct hblk * h_end;    /* Page boundary following block end */
     struct hblk * current;
     GC_bool found_clean;
-    
+
     if (!GC_dirty_maintained) return;
     h_trunc = (struct hblk *)((word)h & ~(GC_page_size-1));
     h_end = (struct hblk *)(((word)(h + nblocks) + GC_page_size-1)
-	                    & ~(GC_page_size-1));
+                      & ~(GC_page_size-1));
     found_clean = FALSE;
     for (current = h_trunc; current < h_end; ++current) {
         int index = PHT_HASH(current);
-            
+
         if (!is_ptrfree || current < h || current >= h + nblocks) {
             async_set_pht_entry_from_index(GC_dirty_pages, index);
         }
@@ -2688,27 +2688,27 @@
 {
 #   if defined(SUNOS5SIGS) || defined(IRIX5) || defined(LINUX) || \
        defined(OSF1) || defined(HURD)
-      struct sigaction	act, oldact;
-      /* We should probably specify SA_SIGINFO for Linux, and handle 	*/
-      /* the different architectures more uniformly.			*/
+      struct sigaction  act, oldact;
+      /* We should probably specify SA_SIGINFO for Linux, and handle  */
+      /* the different architectures more uniformly.      */
 #     if defined(IRIX5) || defined(LINUX) && !defined(X86_64) \
-	 || defined(OSF1) || defined(HURD)
-    	act.sa_flags	= SA_RESTART;
+   || defined(OSF1) || defined(HURD)
+      act.sa_flags  = SA_RESTART;
         act.sa_handler  = (SIG_PF)GC_write_fault_handler;
 #     else
-    	act.sa_flags	= SA_RESTART | SA_SIGINFO;
+      act.sa_flags  = SA_RESTART | SA_SIGINFO;
         act.sa_sigaction = GC_write_fault_handler;
 #     endif
       (void)sigemptyset(&act.sa_mask);
 #     ifdef SIG_SUSPEND
-        /* Arrange to postpone SIG_SUSPEND while we're in a write fault	*/
-        /* handler.  This effectively makes the handler atomic w.r.t.	*/
-        /* stopping the world for GC.					*/
+        /* Arrange to postpone SIG_SUSPEND while we're in a write fault */
+        /* handler.  This effectively makes the handler atomic w.r.t. */
+        /* stopping the world for GC.         */
         (void)sigaddset(&act.sa_mask, SIG_SUSPEND);
 #     endif /* SIG_SUSPEND */
 #    endif
 #   ifdef PRINTSTATS
-	GC_printf0("Inititalizing mprotect virtual dirty bit implementation\n");
+  GC_printf0("Inititalizing mprotect virtual dirty bit implementation\n");
 #   endif
     GC_dirty_maintained = TRUE;
     if (GC_page_size % HBLKSIZE != 0) {
@@ -2722,9 +2722,9 @@
         GC_old_bus_handler = SIG_DFL;
       }
       if (GC_old_bus_handler != SIG_DFL) {
-#	ifdef PRINTSTATS
+# ifdef PRINTSTATS
           GC_err_printf0("Replaced other SIGBUS handler\n");
-#	endif
+# endif
       }
 #   endif
 #   if defined(SUNOS4)
@@ -2734,27 +2734,27 @@
         GC_old_segv_handler = SIG_DFL;
       }
       if (GC_old_segv_handler != SIG_DFL) {
-#	ifdef PRINTSTATS
+# ifdef PRINTSTATS
           GC_err_printf0("Replaced other SIGSEGV handler\n");
-#	endif
+# endif
       }
 #   endif
 #   if (defined(SUNOS5SIGS) && !defined(FREEBSD)) || defined(IRIX5) \
        || defined(LINUX) || defined(OSF1) || defined(HURD)
       /* SUNOS5SIGS includes HPUX */
 #     if defined(GC_IRIX_THREADS)
-      	sigaction(SIGSEGV, 0, &oldact);
-      	sigaction(SIGSEGV, &act, 0);
-#     else 
-	{
-	  int res = sigaction(SIGSEGV, &act, &oldact);
-	  if (res != 0) ABORT("Sigaction failed");
- 	}
+        sigaction(SIGSEGV, 0, &oldact);
+        sigaction(SIGSEGV, &act, 0);
+#     else
+  {
+    int res = sigaction(SIGSEGV, &act, &oldact);
+    if (res != 0) ABORT("Sigaction failed");
+  }
 #     endif
 #     if defined(_sigargs) || defined(HURD) || !defined(SA_SIGINFO)
-	/* This is Irix 5.x, not 6.x.  Irix 5.x does not have	*/
-	/* sa_sigaction.					*/
-	GC_old_segv_handler = oldact.sa_handler;
+  /* This is Irix 5.x, not 6.x.  Irix 5.x does not have */
+  /* sa_sigaction.          */
+  GC_old_segv_handler = oldact.sa_handler;
 #     else /* Irix 6.x or SUNOS5SIGS or LINUX */
         if (oldact.sa_flags & SA_SIGINFO) {
           GC_old_segv_handler = (SIG_PF)(oldact.sa_sigaction);
@@ -2763,12 +2763,12 @@
         }
 #     endif
       if (GC_old_segv_handler == SIG_IGN) {
-	     GC_err_printf0("Previously ignored segmentation violation!?");
-	     GC_old_segv_handler = SIG_DFL;
+       GC_err_printf0("Previously ignored segmentation violation!?");
+       GC_old_segv_handler = SIG_DFL;
       }
       if (GC_old_segv_handler != SIG_DFL) {
 #       ifdef PRINTSTATS
-	  GC_err_printf0("Replaced other SIGSEGV handler\n");
+    GC_err_printf0("Replaced other SIGSEGV handler\n");
 #       endif
       }
 #   endif /* (SUNOS5SIGS && !FREEBSD) || IRIX5 || LINUX || OSF1 || HURD */
@@ -2777,21 +2777,21 @@
       sigaction(SIGBUS, &act, &oldact);
       GC_old_bus_handler = oldact.sa_handler;
       if (GC_old_bus_handler == SIG_IGN) {
-	     GC_err_printf0("Previously ignored bus error!?");
-	     GC_old_bus_handler = SIG_DFL;
+       GC_err_printf0("Previously ignored bus error!?");
+       GC_old_bus_handler = SIG_DFL;
       }
       if (GC_old_bus_handler != SIG_DFL) {
 #       ifdef PRINTSTATS
-	  GC_err_printf0("Replaced other SIGBUS handler\n");
+    GC_err_printf0("Replaced other SIGBUS handler\n");
 #       endif
       }
 #   endif /* HPUX || LINUX || HURD || (FREEBSD && SUNOS5SIGS) */
 #   if defined(MSWIN32)
       GC_old_segv_handler = SetUnhandledExceptionFilter(GC_write_fault_handler);
       if (GC_old_segv_handler != NULL) {
-#	ifdef PRINTSTATS
+# ifdef PRINTSTATS
           GC_err_printf0("Replaced other UnhandledExceptionFilter\n");
-#	endif
+# endif
       } else {
           GC_old_segv_handler = SIG_DFL;
       }
@@ -2802,9 +2802,9 @@
 int GC_incremental_protection_needs()
 {
     if (GC_page_size == HBLKSIZE) {
-	return GC_PROTECTS_POINTER_HEAP;
+  return GC_PROTECTS_POINTER_HEAP;
     } else {
-	return GC_PROTECTS_POINTER_HEAP | GC_PROTECTS_PTRFREE_HEAP;
+  return GC_PROTECTS_POINTER_HEAP | GC_PROTECTS_PTRFREE_HEAP;
     }
 }
 
@@ -2821,60 +2821,60 @@
     struct hblk * current_start;  /* Start of block to be protected. */
     struct hblk * limit;
     unsigned i;
-    GC_bool protect_all = 
-	  (0 != (GC_incremental_protection_needs() & GC_PROTECTS_PTRFREE_HEAP));
+    GC_bool protect_all =
+    (0 != (GC_incremental_protection_needs() & GC_PROTECTS_PTRFREE_HEAP));
     for (i = 0; i < GC_n_heap_sects; i++) {
         start = GC_heap_sects[i].hs_start;
         len = GC_heap_sects[i].hs_bytes;
-	if (protect_all) {
+  if (protect_all) {
           PROTECT(start, len);
-	} else {
-	  GC_ASSERT(PAGE_ALIGNED(len))
-	  GC_ASSERT(PAGE_ALIGNED(start))
-	  current_start = current = (struct hblk *)start;
-	  limit = (struct hblk *)(start + len);
-	  while (current < limit) {
+  } else {
+    GC_ASSERT(PAGE_ALIGNED(len))
+    GC_ASSERT(PAGE_ALIGNED(start))
+    current_start = current = (struct hblk *)start;
+    limit = (struct hblk *)(start + len);
+    while (current < limit) {
             hdr * hhdr;
-	    word nhblks;
-	    GC_bool is_ptrfree;
+      word nhblks;
+      GC_bool is_ptrfree;
 
-	    GC_ASSERT(PAGE_ALIGNED(current));
-	    GET_HDR(current, hhdr);
-	    if (IS_FORWARDING_ADDR_OR_NIL(hhdr)) {
-	      /* This can happen only if we're at the beginning of a 	*/
-	      /* heap segment, and a block spans heap segments.		*/
-	      /* We will handle that block as part of the preceding	*/
-	      /* segment.						*/
-	      GC_ASSERT(current_start == current);
-	      current_start = ++current;
-	      continue;
-	    }
-	    if (HBLK_IS_FREE(hhdr)) {
-	      GC_ASSERT(PAGE_ALIGNED(hhdr -> hb_sz));
-	      nhblks = divHBLKSZ(hhdr -> hb_sz);
-	      is_ptrfree = TRUE;	/* dirty on alloc */
-	    } else {
-	      nhblks = OBJ_SZ_TO_BLOCKS(hhdr -> hb_sz);
-	      is_ptrfree = IS_PTRFREE(hhdr);
-	    }
-	    if (is_ptrfree) {
-	      if (current_start < current) {
-		PROTECT(current_start, (ptr_t)current - (ptr_t)current_start);
-	      }
-	      current_start = (current += nhblks);
-	    } else {
-	      current += nhblks;
-	    }
-	  } 
-	  if (current_start < current) {
-	    PROTECT(current_start, (ptr_t)current - (ptr_t)current_start);
-	  }
-	}
+      GC_ASSERT(PAGE_ALIGNED(current));
+      GET_HDR(current, hhdr);
+      if (IS_FORWARDING_ADDR_OR_NIL(hhdr)) {
+        /* This can happen only if we're at the beginning of a  */
+        /* heap segment, and a block spans heap segments.   */
+        /* We will handle that block as part of the preceding */
+        /* segment.           */
+        GC_ASSERT(current_start == current);
+        current_start = ++current;
+        continue;
+      }
+      if (HBLK_IS_FREE(hhdr)) {
+        GC_ASSERT(PAGE_ALIGNED(hhdr -> hb_sz));
+        nhblks = divHBLKSZ(hhdr -> hb_sz);
+        is_ptrfree = TRUE;  /* dirty on alloc */
+      } else {
+        nhblks = OBJ_SZ_TO_BLOCKS(hhdr -> hb_sz);
+        is_ptrfree = IS_PTRFREE(hhdr);
+      }
+      if (is_ptrfree) {
+        if (current_start < current) {
+    PROTECT(current_start, (ptr_t)current - (ptr_t)current_start);
+        }
+        current_start = (current += nhblks);
+      } else {
+        current += nhblks;
+      }
     }
+    if (current_start < current) {
+      PROTECT(current_start, (ptr_t)current - (ptr_t)current_start);
+    }
+  }
+    }
 }
 
-/* We assume that either the world is stopped or its OK to lose dirty	*/
-/* bits while this is happenning (as in GC_enable_incremental).		*/
+/* We assume that either the world is stopped or its OK to lose dirty */
+/* bits while this is happenning (as in GC_enable_incremental).   */
 void GC_read_dirty()
 {
     BCOPY((word *)GC_dirty_pages, GC_grungy_pages,
@@ -2887,7 +2887,7 @@
 struct hblk * h;
 {
     register word index = PHT_HASH(h);
-    
+
     return(HDR(h) == 0 || get_pht_entry_from_index(GC_grungy_pages, index));
 }
 
@@ -2899,21 +2899,21 @@
  * On other systems, SET_LOCK_HOLDER and friends must be suitably defined.
  */
 
-static GC_bool syscall_acquired_lock = FALSE;	/* Protected by GC lock. */
- 
+static GC_bool syscall_acquired_lock = FALSE; /* Protected by GC lock. */
+
 void GC_begin_syscall()
 {
     if (!I_HOLD_LOCK()) {
-	LOCK();
-	syscall_acquired_lock = TRUE;
+  LOCK();
+  syscall_acquired_lock = TRUE;
     }
 }
 
 void GC_end_syscall()
 {
     if (syscall_acquired_lock) {
-	syscall_acquired_lock = FALSE;
-	UNLOCK();
+  syscall_acquired_lock = FALSE;
+  UNLOCK();
     }
 }
 
@@ -2925,7 +2925,7 @@
     struct hblk * end_block;
     register struct hblk *h;
     ptr_t obj_start;
-    
+
     if (!GC_dirty_maintained) return;
     obj_start = GC_base(addr);
     if (obj_start == 0) return;
@@ -2937,30 +2937,30 @@
     end_block += GC_page_size/HBLKSIZE - 1;
     for (h = start_block; h <= end_block; h++) {
         register word index = PHT_HASH(h);
-        
+
         async_set_pht_entry_from_index(GC_dirty_pages, index);
     }
     UNPROTECT(start_block,
-    	      ((ptr_t)end_block - (ptr_t)start_block) + HBLKSIZE);
+            ((ptr_t)end_block - (ptr_t)start_block) + HBLKSIZE);
 }
 
 #if 0
 
-/* We no longer wrap read by default, since that was causing too many	*/
-/* problems.  It is preferred that the client instead avoids writing	*/
-/* to the write-protected heap with a system call.			*/
+/* We no longer wrap read by default, since that was causing too many */
+/* problems.  It is preferred that the client instead avoids writing  */
+/* to the write-protected heap with a system call.      */
 /* This still serves as sample code if you do want to wrap system calls.*/
 
 #if !defined(MSWIN32) && !defined(MSWINCE) && !defined(GC_USE_LD_WRAP)
-/* Replacement for UNIX system call.					  */
-/* Other calls that write to the heap should be handled similarly.	  */
-/* Note that this doesn't work well for blocking reads:  It will hold	  */
+/* Replacement for UNIX system call.            */
+/* Other calls that write to the heap should be handled similarly.    */
+/* Note that this doesn't work well for blocking reads:  It will hold   */
 /* the allocation lock for the entire duration of the call. Multithreaded */
-/* clients should really ensure that it won't block, either by setting 	  */
-/* the descriptor nonblocking, or by calling select or poll first, to	  */
-/* make sure that input is available.					  */
-/* Another, preferred alternative is to ensure that system calls never 	  */
-/* write to the protected heap (see above).				  */
+/* clients should really ensure that it won't block, either by setting    */
+/* the descriptor nonblocking, or by calling select or poll first, to   */
+/* make sure that input is available.           */
+/* Another, preferred alternative is to ensure that system calls never    */
+/* write to the protected heap (see above).         */
 # if defined(__STDC__) && !defined(SUNOS4)
 #   include <unistd.h>
 #   include <sys/uio.h>
@@ -2977,30 +2977,30 @@
 # endif
 {
     int result;
-    
+
     GC_begin_syscall();
     GC_unprotect_range(buf, (word)nbyte);
 #   if defined(IRIX5) || defined(GC_LINUX_THREADS)
-	/* Indirect system call may not always be easily available.	*/
-	/* We could call _read, but that would interfere with the	*/
-	/* libpthread interception of read.				*/
-	/* On Linux, we have to be careful with the linuxthreads	*/
-	/* read interception.						*/
-	{
-	    struct iovec iov;
+  /* Indirect system call may not always be easily available. */
+  /* We could call _read, but that would interfere with the */
+  /* libpthread interception of read.       */
+  /* On Linux, we have to be careful with the linuxthreads  */
+  /* read interception.           */
+  {
+      struct iovec iov;
 
-	    iov.iov_base = buf;
-	    iov.iov_len = nbyte;
-	    result = readv(fd, &iov, 1);
-	}
+      iov.iov_base = buf;
+      iov.iov_len = nbyte;
+      result = readv(fd, &iov, 1);
+  }
 #   else
-#     if defined(HURD)	
-	result = __read(fd, buf, nbyte);
+#     if defined(HURD)
+  result = __read(fd, buf, nbyte);
 #     else
- 	/* The two zero args at the end of this list are because one
- 	   IA-64 syscall() implementation actually requires six args
- 	   to be passed, even though they aren't always used. */
-     	result = syscall(SYS_read, fd, buf, nbyte, 0, 0);
+  /* The two zero args at the end of this list are because one
+     IA-64 syscall() implementation actually requires six args
+     to be passed, even though they aren't always used. */
+      result = syscall(SYS_read, fd, buf, nbyte, 0, 0);
 #     endif /* !HURD */
 #   endif
     GC_end_syscall();
@@ -3009,25 +3009,25 @@
 #endif /* !MSWIN32 && !MSWINCE && !GC_LINUX_THREADS */
 
 #if defined(GC_USE_LD_WRAP) && !defined(THREADS)
-    /* We use the GNU ld call wrapping facility.			*/
-    /* This requires that the linker be invoked with "--wrap read".	*/
-    /* This can be done by passing -Wl,"--wrap read" to gcc.		*/
-    /* I'm not sure that this actually wraps whatever version of read	*/
-    /* is called by stdio.  That code also mentions __read.		*/
+    /* We use the GNU ld call wrapping facility.      */
+    /* This requires that the linker be invoked with "--wrap read". */
+    /* This can be done by passing -Wl,"--wrap read" to gcc.    */
+    /* I'm not sure that this actually wraps whatever version of read */
+    /* is called by stdio.  That code also mentions __read.   */
 #   include <unistd.h>
     ssize_t __wrap_read(int fd, void *buf, size_t nbyte)
     {
- 	int result;
+  int result;
 
-	GC_begin_syscall();
-    	GC_unprotect_range(buf, (word)nbyte);
-	result = __real_read(fd, buf, nbyte);
-	GC_end_syscall();
-	return(result);
+  GC_begin_syscall();
+      GC_unprotect_range(buf, (word)nbyte);
+  result = __real_read(fd, buf, nbyte);
+  GC_end_syscall();
+  return(result);
     }
 
-    /* We should probably also do this for __read, or whatever stdio	*/
-    /* actually calls.							*/
+    /* We should probably also do this for __read, or whatever stdio  */
+    /* actually calls.              */
 #endif
 
 #endif /* 0 */
@@ -3039,7 +3039,7 @@
     return(TRUE);
 }
 
-/* Reset the n pages starting at h to "was never dirty" status.	*/
+/* Reset the n pages starting at h to "was never dirty" status. */
 /*ARGSUSED*/
 void GC_is_fresh(h, n)
 struct hblk *h;
@@ -3054,7 +3054,7 @@
 /*
  * See DEFAULT_VDB for interface descriptions.
  */
- 
+
 /*
  * This implementaion assumes a Solaris 2.X like /proc pseudo-file-system
  * from which we can read page modified bits.  This facility is far from
@@ -3075,20 +3075,20 @@
 char *GC_proc_buf;
 
 #ifdef GC_SOLARIS_THREADS
-/* We don't have exact sp values for threads.  So we count on	*/
-/* occasionally declaring stack pages to be fresh.  Thus we 	*/
-/* need a real implementation of GC_is_fresh.  We can't clear	*/
-/* entries in GC_written_pages, since that would declare all	*/
-/* pages with the given hash address to be fresh.		*/
-#   define MAX_FRESH_PAGES 8*1024	/* Must be power of 2 */
-    struct hblk ** GC_fresh_pages;	/* A direct mapped cache.	*/
-    					/* Collisions are dropped.	*/
+/* We don't have exact sp values for threads.  So we count on */
+/* occasionally declaring stack pages to be fresh.  Thus we   */
+/* need a real implementation of GC_is_fresh.  We can't clear */
+/* entries in GC_written_pages, since that would declare all  */
+/* pages with the given hash address to be fresh.   */
+#   define MAX_FRESH_PAGES 8*1024 /* Must be power of 2 */
+    struct hblk ** GC_fresh_pages;  /* A direct mapped cache. */
+              /* Collisions are dropped.  */
 
 #   define FRESH_PAGE_SLOT(h) (divHBLKSZ((word)(h)) & (MAX_FRESH_PAGES-1))
 #   define ADD_FRESH_PAGE(h) \
-	GC_fresh_pages[FRESH_PAGE_SLOT(h)] = (h)
+  GC_fresh_pages[FRESH_PAGE_SLOT(h)] = (h)
 #   define PAGE_IS_FRESH(h) \
-	(GC_fresh_pages[FRESH_PAGE_SLOT(h)] == (h) && (h) != 0)
+  (GC_fresh_pages[FRESH_PAGE_SLOT(h)] == (h) && (h) != 0)
 #endif
 
 /* Add all pages in pht2 to pht1 */
@@ -3096,7 +3096,7 @@
 page_hash_table pht1, pht2;
 {
     register int i;
-    
+
     for (i = 0; i < PHT_SIZE; i++) pht1[i] |= pht2[i];
 }
 
@@ -3109,39 +3109,39 @@
 
     GC_dirty_maintained = TRUE;
     if (GC_words_allocd != 0 || GC_words_allocd_before_gc != 0) {
-    	register int i;
-    
+      register int i;
+
         for (i = 0; i < PHT_SIZE; i++) GC_written_pages[i] = (word)(-1);
 #       ifdef PRINTSTATS
-	    GC_printf1("Allocated words:%lu:all pages may have been written\n",
-	    	       (unsigned long)
-	    	      		(GC_words_allocd + GC_words_allocd_before_gc));
-#	endif       
+      GC_printf1("Allocated words:%lu:all pages may have been written\n",
+               (unsigned long)
+                  (GC_words_allocd + GC_words_allocd_before_gc));
+# endif
     }
     sprintf(buf, "/proc/%d", getpid());
     fd = open(buf, O_RDONLY);
     if (fd < 0) {
-    	ABORT("/proc open failed");
+      ABORT("/proc open failed");
     }
     GC_proc_fd = syscall(SYS_ioctl, fd, PIOCOPENPD, 0);
     close(fd);
     syscall(SYS_fcntl, GC_proc_fd, F_SETFD, FD_CLOEXEC);
     if (GC_proc_fd < 0) {
-    	ABORT("/proc ioctl failed");
+      ABORT("/proc ioctl failed");
     }
     GC_proc_buf = GC_scratch_alloc(GC_proc_buf_size);
 #   ifdef GC_SOLARIS_THREADS
-	GC_fresh_pages = (struct hblk **)
-	  GC_scratch_alloc(MAX_FRESH_PAGES * sizeof (struct hblk *));
-	if (GC_fresh_pages == 0) {
-	    GC_err_printf0("No space for fresh pages\n");
-	    EXIT();
-	}
-	BZERO(GC_fresh_pages, MAX_FRESH_PAGES * sizeof (struct hblk *));
+  GC_fresh_pages = (struct hblk **)
+    GC_scratch_alloc(MAX_FRESH_PAGES * sizeof (struct hblk *));
+  if (GC_fresh_pages == 0) {
+      GC_err_printf0("No space for fresh pages\n");
+      EXIT();
+  }
+  BZERO(GC_fresh_pages, MAX_FRESH_PAGES * sizeof (struct hblk *));
 #   endif
 }
 
-/* Ignore write hints. They don't help us here.	*/
+/* Ignore write hints. They don't help us here. */
 /*ARGSUSED*/
 void GC_remove_protection(h, nblocks, is_ptrfree)
 struct hblk *h;
@@ -3168,79 +3168,79 @@
 int dummy;
 
     BZERO(GC_grungy_pages, (sizeof GC_grungy_pages));
-    
+
     bufp = GC_proc_buf;
     if (READ(GC_proc_fd, bufp, GC_proc_buf_size) <= 0) {
-#	ifdef PRINTSTATS
+# ifdef PRINTSTATS
             GC_printf1("/proc read failed: GC_proc_buf_size = %lu\n",
-            	       GC_proc_buf_size);
-#	endif       
+                     GC_proc_buf_size);
+# endif
         {
             /* Retry with larger buffer. */
             word new_size = 2 * GC_proc_buf_size;
             char * new_buf = GC_scratch_alloc(new_size);
-            
+
             if (new_buf != 0) {
                 GC_proc_buf = bufp = new_buf;
                 GC_proc_buf_size = new_size;
             }
             if (READ(GC_proc_fd, bufp, GC_proc_buf_size) <= 0) {
                 WARN("Insufficient space for /proc read\n", 0);
-                /* Punt:	*/
-        	memset(GC_grungy_pages, 0xff, sizeof (page_hash_table));
-		memset(GC_written_pages, 0xff, sizeof(page_hash_table));
-#		ifdef GC_SOLARIS_THREADS
-		    BZERO(GC_fresh_pages,
-		    	  MAX_FRESH_PAGES * sizeof (struct hblk *)); 
-#		endif
-		return;
+                /* Punt:  */
+          memset(GC_grungy_pages, 0xff, sizeof (page_hash_table));
+    memset(GC_written_pages, 0xff, sizeof(page_hash_table));
+#   ifdef GC_SOLARIS_THREADS
+        BZERO(GC_fresh_pages,
+            MAX_FRESH_PAGES * sizeof (struct hblk *));
+#   endif
+    return;
             }
         }
     }
     /* Copy dirty bits into GC_grungy_pages */
-    	nmaps = ((struct prpageheader *)bufp) -> pr_nmap;
-	/* printf( "nmaps = %d, PG_REFERENCED = %d, PG_MODIFIED = %d\n",
-		     nmaps, PG_REFERENCED, PG_MODIFIED); */
-	bufp = bufp + sizeof(struct prpageheader);
-	for (i = 0; i < nmaps; i++) {
-	    map = (struct prasmap *)bufp;
-	    vaddr = (ptr_t)(map -> pr_vaddr);
-	    ps = map -> pr_pagesize;
-	    np = map -> pr_npage;
-	    /* printf("vaddr = 0x%X, ps = 0x%X, np = 0x%X\n", vaddr, ps, np); */
-	    limit = vaddr + ps * np;
-	    bufp += sizeof (struct prasmap);
-	    for (current_addr = vaddr;
-	         current_addr < limit; current_addr += ps){
-	        if ((*bufp++) & PG_MODIFIED) {
-	            register struct hblk * h = (struct hblk *) current_addr;
-	            
-	            while ((ptr_t)h < current_addr + ps) {
-	                register word index = PHT_HASH(h);
-	                
-	                set_pht_entry_from_index(GC_grungy_pages, index);
-#			ifdef GC_SOLARIS_THREADS
-			  {
-			    register int slot = FRESH_PAGE_SLOT(h);
-			    
-			    if (GC_fresh_pages[slot] == h) {
-			        GC_fresh_pages[slot] = 0;
-			    }
-			  }
-#			endif
-	                h++;
-	            }
-	        }
-	    }
-	    bufp += sizeof(long) - 1;
-	    bufp = (char *)((unsigned long)bufp & ~(sizeof(long)-1));
-	}
+      nmaps = ((struct prpageheader *)bufp) -> pr_nmap;
+  /* printf( "nmaps = %d, PG_REFERENCED = %d, PG_MODIFIED = %d\n",
+         nmaps, PG_REFERENCED, PG_MODIFIED); */
+  bufp = bufp + sizeof(struct prpageheader);
+  for (i = 0; i < nmaps; i++) {
+      map = (struct prasmap *)bufp;
+      vaddr = (ptr_t)(map -> pr_vaddr);
+      ps = map -> pr_pagesize;
+      np = map -> pr_npage;
+      /* printf("vaddr = 0x%X, ps = 0x%X, np = 0x%X\n", vaddr, ps, np); */
+      limit = vaddr + ps * np;
+      bufp += sizeof (struct prasmap);
+      for (current_addr = vaddr;
+           current_addr < limit; current_addr += ps){
+          if ((*bufp++) & PG_MODIFIED) {
+              register struct hblk * h = (struct hblk *) current_addr;
+
+              while ((ptr_t)h < current_addr + ps) {
+                  register word index = PHT_HASH(h);
+
+                  set_pht_entry_from_index(GC_grungy_pages, index);
+#     ifdef GC_SOLARIS_THREADS
+        {
+          register int slot = FRESH_PAGE_SLOT(h);
+
+          if (GC_fresh_pages[slot] == h) {
+              GC_fresh_pages[slot] = 0;
+          }
+        }
+#     endif
+                  h++;
+              }
+          }
+      }
+      bufp += sizeof(long) - 1;
+      bufp = (char *)((unsigned long)bufp & ~(sizeof(long)-1));
+  }
     /* Update GC_written_pages. */
         GC_or_pages(GC_written_pages, GC_grungy_pages);
 #   ifdef GC_SOLARIS_THREADS
-      /* Make sure that old stacks are considered completely clean	*/
-      /* unless written again.						*/
-	GC_old_stacks_are_fresh();
+      /* Make sure that old stacks are considered completely clean  */
+      /* unless written again.            */
+  GC_old_stacks_are_fresh();
 #   endif
 }
 
@@ -3251,15 +3251,15 @@
 {
     register word index = PHT_HASH(h);
     register GC_bool result;
-    
+
     result = get_pht_entry_from_index(GC_grungy_pages, index);
 #   ifdef GC_SOLARIS_THREADS
-	if (result && PAGE_IS_FRESH(h)) result = FALSE;
-	/* This happens only if page was declared fresh since	*/
-	/* the read_dirty call, e.g. because it's in an unused  */
-	/* thread stack.  It's OK to treat it as clean, in	*/
-	/* that case.  And it's consistent with 		*/
-	/* GC_page_was_ever_dirty.				*/
+  if (result && PAGE_IS_FRESH(h)) result = FALSE;
+  /* This happens only if page was declared fresh since */
+  /* the read_dirty call, e.g. because it's in an unused  */
+  /* thread stack.  It's OK to treat it as clean, in  */
+  /* that case.  And it's consistent with     */
+  /* GC_page_was_ever_dirty.        */
 #   endif
     return(result);
 }
@@ -3269,25 +3269,25 @@
 {
     register word index = PHT_HASH(h);
     register GC_bool result;
-    
+
     result = get_pht_entry_from_index(GC_written_pages, index);
 #   ifdef GC_SOLARIS_THREADS
-	if (result && PAGE_IS_FRESH(h)) result = FALSE;
+  if (result && PAGE_IS_FRESH(h)) result = FALSE;
 #   endif
     return(result);
 }
 
-/* Caller holds allocation lock.	*/
+/* Caller holds allocation lock.  */
 void GC_is_fresh(h, n)
 struct hblk *h;
 word n;
 {
 
     register word index;
-    
+
 #   ifdef GC_SOLARIS_THREADS
       register word i;
-      
+
       if (GC_fresh_pages != 0) {
         for (i = 0; i < n; i++) {
           ADD_FRESH_PAGE(h + i);
@@ -3303,12 +3303,12 @@
 
 # include "vd/PCR_VD.h"
 
-# define NPAGES (32*1024)	/* 128 MB */
+# define NPAGES (32*1024) /* 128 MB */
 
 PCR_VD_DB  GC_grungy_bits[NPAGES];
 
-ptr_t GC_vd_base;	/* Address corresponding to GC_grungy_bits[0]	*/
-			/* HBLKSIZE aligned.				*/
+ptr_t GC_vd_base; /* Address corresponding to GC_grungy_bits[0] */
+      /* HBLKSIZE aligned.        */
 
 void GC_dirty_init()
 {
@@ -3316,11 +3316,11 @@
     /* For the time being, we assume the heap generally grows up */
     GC_vd_base = GC_heap_sects[0].hs_start;
     if (GC_vd_base == 0) {
-   	ABORT("Bad initial heap segment");
+    ABORT("Bad initial heap segment");
     }
     if (PCR_VD_Start(HBLKSIZE, GC_vd_base, NPAGES*HBLKSIZE)
-	!= PCR_ERes_okay) {
-	ABORT("dirty bit initialization failed");
+  != PCR_ERes_okay) {
+  ABORT("dirty bit initialization failed");
     }
 }
 
@@ -3340,7 +3340,7 @@
 
     if (PCR_VD_Clear(GC_vd_base, NPAGES*HBLKSIZE, GC_grungy_bits)
         != PCR_ERes_okay) {
-	ABORT("dirty bit read failed");
+  ABORT("dirty bit read failed");
     }
 }
 
@@ -3348,7 +3348,7 @@
 struct hblk *h;
 {
     if((ptr_t)h < GC_vd_base || (ptr_t)h >= GC_vd_base + NPAGES*HBLKSIZE) {
-	return(TRUE);
+  return(TRUE);
     }
     return(GC_grungy_bits[h - (struct hblk *)GC_vd_base] & PCR_VD_DB_dirtyBit);
 }
@@ -3370,15 +3370,15 @@
    code:
       1. Apple's mach/xnu documentation
       2. Timothy J. Wood's "Mach Exception Handlers 101" post to the
-         omnigroup's macosx-dev list. 
+         omnigroup's macosx-dev list.
          www.omnigroup.com/mailman/archive/macosx-dev/2000-June/002030.html
       3. macosx-nat.c from Apple's GDB source code.
 */
-   
+
 /* The bug that caused all this trouble should now be fixed. This should
    eventually be removed if all goes well. */
 /* define BROKEN_EXCEPTION_HANDLING */
-    
+
 #include <mach/mach.h>
 #include <mach/mach_error.h>
 #include <mach/thread_status.h>
@@ -3449,13 +3449,13 @@
     } buf;
     mach_msg_return_t r;
     /* remote, local */
-    buf.msg.head.msgh_bits = 
+    buf.msg.head.msgh_bits =
         MACH_MSGH_BITS(MACH_MSG_TYPE_MAKE_SEND,0);
     buf.msg.head.msgh_size = sizeof(buf.msg);
     buf.msg.head.msgh_remote_port = GC_ports.exception;
     buf.msg.head.msgh_local_port = MACH_PORT_NULL;
     buf.msg.head.msgh_id = id;
-            
+
     r = mach_msg(
         &buf.msg.head,
         MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_LARGE,
@@ -3465,7 +3465,7 @@
         MACH_MSG_TIMEOUT_NONE,
         MACH_PORT_NULL);
     if(r != MACH_MSG_SUCCESS)
-	ABORT("mach_msg failed in GC_mprotect_thread_notify");
+  ABORT("mach_msg failed in GC_mprotect_thread_notify");
     if(buf.msg.head.msgh_id != ID_ACK)
         ABORT("invalid ack in GC_mprotect_thread_notify");
 }
@@ -3475,13 +3475,13 @@
     GC_msg_t msg;
     mach_msg_return_t r;
     /* remote, local */
-    msg.head.msgh_bits = 
+    msg.head.msgh_bits =
         MACH_MSGH_BITS(MACH_MSG_TYPE_MAKE_SEND,0);
     msg.head.msgh_size = sizeof(msg);
     msg.head.msgh_remote_port = GC_ports.reply;
     msg.head.msgh_local_port = MACH_PORT_NULL;
     msg.head.msgh_id = ID_ACK;
-            
+
     r = mach_msg(
         &msg.head,
         MACH_SEND_MSG,
@@ -3491,7 +3491,7 @@
         MACH_MSG_TIMEOUT_NONE,
         MACH_PORT_NULL);
     if(r != MACH_MSG_SUCCESS)
-	ABORT("mach_msg failed in GC_mprotect_thread_reply");
+  ABORT("mach_msg failed in GC_mprotect_thread_reply");
 }
 
 void GC_mprotect_stop() {
@@ -3524,7 +3524,7 @@
     mach_msg_id_t id;
 
     GC_darwin_register_mach_handler_thread(mach_thread_self());
-    
+
     for(;;) {
         r = mach_msg(
             &msg.head,
@@ -3535,9 +3535,9 @@
             GC_ports.exception,
             GC_mprotect_state == GC_MP_DISCARDING ? 0 : MACH_MSG_TIMEOUT_NONE,
             MACH_PORT_NULL);
-        
+
         id = r == MACH_MSG_SUCCESS ? msg.head.msgh_id : -1;
-        
+
 #if defined(THREADS)
         if(GC_mprotect_state == GC_MP_DISCARDING) {
             if(r == MACH_RCV_TIMED_OUT) {
@@ -3549,13 +3549,13 @@
                 ABORT("out of order mprotect thread request");
         }
 #endif
-        
+
         if(r != MACH_MSG_SUCCESS) {
-            GC_err_printf2("mach_msg failed with %d %s\n", 
+            GC_err_printf2("mach_msg failed with %d %s\n",
                 (int)r,mach_error_string(r));
             ABORT("mach_msg failed");
         }
-        
+
         switch(id) {
 #if defined(THREADS)
             case ID_STOP:
@@ -3571,8 +3571,8 @@
                 break;
 #endif /* THREADS */
             default:
-	            /* Handle the message (calls catch_exception_raise) */
-    	        if(!exc_server(&msg.head,&reply.head))
+              /* Handle the message (calls catch_exception_raise) */
+              if(!exc_server(&msg.head,&reply.head))
                     ABORT("exc_server failed");
                 /* Send the reply */
                 r = mach_msg(
@@ -3583,17 +3583,17 @@
                     MACH_PORT_NULL,
                     MACH_MSG_TIMEOUT_NONE,
                     MACH_PORT_NULL);
-	        if(r != MACH_MSG_SUCCESS) {
-	        	/* This will fail if the thread dies, but the thread shouldn't
-	        	   die... */
-	        	#ifdef BROKEN_EXCEPTION_HANDLING
-    	        	GC_err_printf2(
+          if(r != MACH_MSG_SUCCESS) {
+            /* This will fail if the thread dies, but the thread shouldn't
+               die... */
+            #ifdef BROKEN_EXCEPTION_HANDLING
+                GC_err_printf2(
                         "mach_msg failed with %d %s while sending exc reply\n",
                         (int)r,mach_error_string(r));
-    	        #else
-    	        	ABORT("mach_msg failed while sending exception reply");
-    	        #endif
-        	}
+              #else
+                ABORT("mach_msg failed while sending exception reply");
+              #endif
+          }
         } /* switch */
     } /* for(;;) */
     /* NOT REACHED */
@@ -3615,7 +3615,7 @@
 
 static void GC_darwin_sigbus(int num,siginfo_t *sip,void *context) {
     if(num != SIGBUS) ABORT("Got a non-sigbus signal in the sigbus handler");
-    
+
     /* Ugh... some seem safe to ignore, but too many in a row probably means
        trouble. GC_sigbus_count is reset for each mach exception that is
        handled */
@@ -3634,37 +3634,37 @@
     pthread_t thread;
     pthread_attr_t attr;
     exception_mask_t mask;
-    
+
 #   ifdef PRINTSTATS
         GC_printf0("Inititalizing mach/darwin mprotect virtual dirty bit "
             "implementation\n");
-#   endif  
-#	ifdef BROKEN_EXCEPTION_HANDLING
+#   endif
+# ifdef BROKEN_EXCEPTION_HANDLING
         GC_err_printf0("GC: WARNING: Enabling workarounds for various darwin "
             "exception handling bugs.\n");
-#	endif
+# endif
     GC_dirty_maintained = TRUE;
     if (GC_page_size % HBLKSIZE != 0) {
         GC_err_printf0("Page size not multiple of HBLKSIZE\n");
         ABORT("Page size not multiple of HBLKSIZE");
     }
-    
+
     GC_task_self = me = mach_task_self();
-    
+
     r = mach_port_allocate(me,MACH_PORT_RIGHT_RECEIVE,&GC_ports.exception);
     if(r != KERN_SUCCESS) ABORT("mach_port_allocate failed (exception port)");
-    
+
     r = mach_port_insert_right(me,GC_ports.exception,GC_ports.exception,
-    	MACH_MSG_TYPE_MAKE_SEND);
+      MACH_MSG_TYPE_MAKE_SEND);
     if(r != KERN_SUCCESS)
-    	ABORT("mach_port_insert_right failed (exception port)");
+      ABORT("mach_port_insert_right failed (exception port)");
 
     #if defined(THREADS)
         r = mach_port_allocate(me,MACH_PORT_RIGHT_RECEIVE,&GC_ports.reply);
         if(r != KERN_SUCCESS) ABORT("mach_port_allocate failed (reply port)");
     #endif
 
-    /* The exceptions we want to catch */  
+    /* The exceptions we want to catch */
     mask = EXC_MASK_BAD_ACCESS;
 
     r = task_get_exception_ports(
@@ -3677,7 +3677,7 @@
         GC_old_exc_ports.flavors
     );
     if(r != KERN_SUCCESS) ABORT("task_get_exception_ports failed");
-        
+
     r = task_set_exception_ports(
         me,
         mask,
@@ -3688,17 +3688,17 @@
     if(r != KERN_SUCCESS) ABORT("task_set_exception_ports failed");
 
     if(pthread_attr_init(&attr) != 0) ABORT("pthread_attr_init failed");
-    if(pthread_attr_setdetachstate(&attr,PTHREAD_CREATE_DETACHED) != 0) 
+    if(pthread_attr_setdetachstate(&attr,PTHREAD_CREATE_DETACHED) != 0)
         ABORT("pthread_attr_setdetachedstate failed");
 
-#	undef pthread_create
+# undef pthread_create
     /* This will call the real pthread function, not our wrapper */
     if(pthread_create(&thread,&attr,GC_mprotect_thread,NULL) != 0)
         ABORT("pthread_create failed");
     pthread_attr_destroy(&attr);
-    
+
     /* Setup the sigbus handler for ignoring the meaningless SIGBUSs */
-    #ifdef BROKEN_EXCEPTION_HANDLING 
+    #ifdef BROKEN_EXCEPTION_HANDLING
     {
         struct sigaction sa, oldsa;
         sa.sa_handler = (SIG_PF)GC_darwin_sigbus;
@@ -3707,16 +3707,16 @@
         if(sigaction(SIGBUS,&sa,&oldsa) < 0) ABORT("sigaction");
         GC_old_bus_handler = (SIG_PF)oldsa.sa_handler;
         if (GC_old_bus_handler != SIG_DFL) {
-#       	ifdef PRINTSTATS
+#         ifdef PRINTSTATS
                 GC_err_printf0("Replaced other SIGBUS handler\n");
-#       	endif
+#         endif
         }
     }
     #endif /* BROKEN_EXCEPTION_HANDLING  */
 }
- 
+
 /* The source code for Apple's GDB was used as a reference for the exception
-   forwarding code. This code is similar to be GDB code only because there is 
+   forwarding code. This code is similar to be GDB code only because there is
    only one way to do it. */
 static kern_return_t GC_forward_exception(
         mach_port_t thread,
@@ -3730,15 +3730,15 @@
     mach_port_t port;
     exception_behavior_t behavior;
     thread_state_flavor_t flavor;
-    
+
     thread_state_t thread_state;
     mach_msg_type_number_t thread_state_count = THREAD_STATE_MAX;
-        
+
     for(i=0;i<GC_old_exc_ports.count;i++)
         if(GC_old_exc_ports.masks[i] & (1 << exception))
             break;
     if(i==GC_old_exc_ports.count) ABORT("No handler for exception!");
-    
+
     port = GC_old_exc_ports.ports[i];
     behavior = GC_old_exc_ports.behaviors[i];
     flavor = GC_old_exc_ports.flavors[i];
@@ -3748,7 +3748,7 @@
         if(r != KERN_SUCCESS)
             ABORT("thread_get_state failed in forward_exception");
     }
-    
+
     switch(behavior) {
         case EXCEPTION_DEFAULT:
             r = exception_raise(port,thread,task,exception,data,data_count);
@@ -3768,13 +3768,13 @@
             ABORT("forward_exception: unknown behavior");
             break;
     }
-    
+
     if(behavior != EXCEPTION_DEFAULT) {
         r = thread_set_state(thread,flavor,thread_state,thread_state_count);
         if(r != KERN_SUCCESS)
             ABORT("thread_set_state failed in forward_exception");
     }
-    
+
     return r;
 }
 
@@ -3802,22 +3802,29 @@
         mach_msg_type_number_t exc_state_count = PPC_EXCEPTION_STATE64_COUNT;
         ppc_exception_state64_t exc_state;
 #     endif
-#   elif defined(I386)
+#   elif defined(I386) || defined(X86_64)
+#     if CPP_WORDSZ == 32
         thread_state_flavor_t flavor = i386_EXCEPTION_STATE;
         mach_msg_type_number_t exc_state_count = i386_EXCEPTION_STATE_COUNT;
         i386_exception_state_t exc_state;
+#     else
+        thread_state_flavor_t flavor = x86_EXCEPTION_STATE64;
+        mach_msg_type_number_t exc_state_count = x86_EXCEPTION_STATE64_COUNT;
+        x86_exception_state64_t exc_state;
+#     endif
+#     define DARWIN_EXC_STATE_DAR     THREAD_FLD(faultvaddr)
 #   else
-#	error FIXME for non-ppc/x86 darwin
+# error FIXME for non-ppc/x86 darwin
 #   endif
 
-    
+
     if(exception != EXC_BAD_ACCESS || code[0] != KERN_PROTECTION_FAILURE) {
         #ifdef DEBUG_EXCEPTION_HANDLING
         /* We aren't interested, pass it on to the old handler */
         GC_printf3("Exception: 0x%x Code: 0x%x 0x%x in catch....\n",
             exception,
             code_count > 0 ? code[0] : -1,
-            code_count > 1 ? code[1] : -1); 
+            code_count > 1 ? code[1] : -1);
         #endif
         return FWD();
     }
@@ -3835,26 +3842,26 @@
             ABORT("thread_get_state failed in catch_exception_raise");
         #endif
     }
-    
+
     /* This is the address that caused the fault */
 #if defined(POWERPC)
     addr = (char*) exc_state.dar;
-#elif defined (I386)
-    addr = (char*) exc_state.faultvaddr;
+#elif defined (I386) || defined(X86_64)
+    addr = (char*) exc_state.DARWIN_EXC_STATE_DAR;
 #else
 #   error FIXME for non POWERPC/I386
 #endif
-        
+
     if((HDR(addr)) == 0) {
-        /* Ugh... just like the SIGBUS problem above, it seems we get a bogus 
+        /* Ugh... just like the SIGBUS problem above, it seems we get a bogus
            KERN_PROTECTION_FAILURE every once and a while. We wait till we get
-           a bunch in a row before doing anything about it. If a "real" fault 
+           a bunch in a row before doing anything about it. If a "real" fault
            ever occurres it'll just keep faulting over and over and we'll hit
            the limit pretty quickly. */
         #ifdef BROKEN_EXCEPTION_HANDLING
             static char *last_fault;
             static int last_fault_count;
-            
+
             if(addr != last_fault) {
                 last_fault = addr;
                 last_fault_count = 0;
@@ -3866,7 +3873,7 @@
                         addr);
                 return KERN_SUCCESS;
             }
-            
+
             GC_err_printf1("Unexpected KERN_PROTECTION_FAILURE at %p\n",addr);
             /* Can't pass it along to the signal handler because that is
                ignoring SIGBUS signals. We also shouldn't call ABORT here as
@@ -3874,7 +3881,7 @@
             GC_err_printf0("Aborting\n");
             exit(EXIT_FAILURE);
         #else /* BROKEN_EXCEPTION_HANDLING */
-            /* Pass it along to the next exception handler 
+            /* Pass it along to the next exception handler
                (which should call SIGBUS/SIGSEGV) */
             return FWD();
         #endif /* !BROKEN_EXCEPTION_HANDLING */
@@ -3884,10 +3891,10 @@
         /* Reset the number of consecutive SIGBUSs */
         GC_sigbus_count = 0;
     #endif
-    
+
     if(GC_mprotect_state == GC_MP_NORMAL) { /* common case */
         h = (struct hblk*)((word)addr & ~(GC_page_size-1));
-        UNPROTECT(h, GC_page_size);	
+        UNPROTECT(h, GC_page_size);
         for (i = 0; i < divHBLKSZ(GC_page_size); i++) {
             register int index = PHT_HASH(h+i);
             async_set_pht_entry_from_index(GC_dirty_pages, index);
@@ -3917,7 +3924,7 @@
 kern_return_t catch_exception_raise_state_identity(
     mach_port_name_t exception_port, mach_port_t thread, mach_port_t task,
     int exception, exception_data_t code, mach_msg_type_number_t codeCnt,
-    int flavor, thread_state_t old_state, int old_stateCnt, 
+    int flavor, thread_state_t old_state, int old_stateCnt,
     thread_state_t new_state, int new_stateCnt)
 {
     ABORT("catch_exception_raise_state_identity");
@@ -3939,16 +3946,16 @@
  * Should probably be in mach_dep.c, but that requires reorganization.
  */
 
-/* I suspect the following works for most X86 *nix variants, so 	*/
-/* long as the frame pointer is explicitly stored.  In the case of gcc,	*/
-/* compiler flags (e.g. -fomit-frame-pointer) determine whether it is.	*/
+/* I suspect the following works for most X86 *nix variants, so   */
+/* long as the frame pointer is explicitly stored.  In the case of gcc, */
+/* compiler flags (e.g. -fomit-frame-pointer) determine whether it is.  */
 #if defined(I386) && defined(LINUX) && defined(SAVE_CALL_CHAIN)
 #   include <features.h>
 
     struct frame {
-	struct frame *fr_savfp;
-	long	fr_savpc;
-        long	fr_arg[NARGS];  /* All the arguments go here.	*/
+  struct frame *fr_savfp;
+  long  fr_savpc;
+        long  fr_arg[NARGS];  /* All the arguments go here. */
     };
 #endif
 
@@ -3957,43 +3964,43 @@
 #    include <features.h>
 
      struct frame {
-	long	fr_local[8];
-	long	fr_arg[6];
-	struct frame *fr_savfp;
-	long	fr_savpc;
+  long  fr_local[8];
+  long  fr_arg[6];
+  struct frame *fr_savfp;
+  long  fr_savpc;
 #       ifndef __arch64__
-	  char	*fr_stret;
+    char  *fr_stret;
 #       endif
-	long	fr_argd[6];
-	long	fr_argx[0];
+  long  fr_argd[6];
+  long  fr_argx[0];
      };
 #  else
 #    if defined(SUNOS4)
 #      include <machine/frame.h>
 #    else
 #      if defined (DRSNX)
-#	 include <sys/sparc/frame.h>
+#  include <sys/sparc/frame.h>
 #      else
-#	 if defined(OPENBSD)
-#	   include <frame.h>
-#	 else
-#	   if defined(FREEBSD) || defined(NETBSD)
-#	     include <machine/frame.h>
-#	   else
-#	     include <sys/frame.h>
-#	   endif
-#	 endif
+#  if defined(OPENBSD)
+#    include <frame.h>
+#  else
+#    if defined(FREEBSD) || defined(NETBSD)
+#      include <machine/frame.h>
+#    else
+#      include <sys/frame.h>
+#    endif
+#  endif
 #      endif
 #    endif
 #  endif
 #  if NARGS > 6
-	--> We only know how to to get the first 6 arguments
+  --> We only know how to to get the first 6 arguments
 #  endif
 #endif /* SPARC */
 
 #ifdef  NEED_CALLINFO
-/* Fill in the pc and argument information for up to NFRAMES of my	*/
-/* callers.  Ignore my frame and my callers frame.			*/
+/* Fill in the pc and argument information for up to NFRAMES of my  */
+/* callers.  Ignore my frame and my callers frame.      */
 
 #ifdef LINUX
 #   include <unistd.h>
@@ -4011,24 +4018,24 @@
     && defined(GC_HAVE_BUILTIN_BACKTRACE)
 
 #ifdef REDIRECT_MALLOC
-  /* Deal with possible malloc calls in backtrace by omitting	*/
-  /* the infinitely recursing backtrace.			*/
+  /* Deal with possible malloc calls in backtrace by omitting */
+  /* the infinitely recursing backtrace.      */
 # ifdef THREADS
-    __thread 	/* If your compiler doesn't understand this */
-    		/* you could use something like pthread_getspecific.	*/
+    __thread  /* If your compiler doesn't understand this */
+        /* you could use something like pthread_getspecific.  */
 # endif
   GC_in_save_callers = FALSE;
 #endif
 
-void GC_save_callers (info) 
+void GC_save_callers (info)
 struct callinfo info[NFRAMES];
 {
   void * tmp_info[NFRAMES + 1];
   int npcs, i;
 # define IGNORE_FRAMES 1
-  
-  /* We retrieve NFRAMES+1 pc values, but discard the first, since it	*/
-  /* points to our own frame.						*/
+
+  /* We retrieve NFRAMES+1 pc values, but discard the first, since it */
+  /* points to our own frame.           */
 # ifdef REDIRECT_MALLOC
     if (GC_in_save_callers) {
       info[0].ci_pc = (word)(&GC_save_callers);
@@ -4062,7 +4069,7 @@
 #   define BIAS 0
 #endif
 
-void GC_save_callers (info) 
+void GC_save_callers (info)
 struct callinfo info[NFRAMES];
 {
   struct frame *frame;
@@ -4076,16 +4083,16 @@
     frame = (struct frame *) GC_save_regs_in_stack ();
     fp = (struct frame *)((long) frame -> FR_SAVFP + BIAS);
 #endif
-  
+
    for (; (!(fp HOTTER_THAN frame) && !(GC_stackbottom HOTTER_THAN (ptr_t)fp)
-	   && (nframes < NFRAMES));
+     && (nframes < NFRAMES));
        fp = (struct frame *)((long) fp -> FR_SAVFP + BIAS), nframes++) {
       register int i;
-      
+
       info[nframes].ci_pc = fp->FR_SAVPC;
 #     if NARGS > 0
         for (i = 0; i < NARGS; i++) {
-	  info[nframes].ci_arg[i] = ~(fp->fr_arg[i]);
+    info[nframes].ci_arg[i] = ~(fp->fr_arg[i]);
         }
 #     endif /* NARGS > 0 */
   }
@@ -4106,141 +4113,141 @@
     static int reentry_count = 0;
     GC_bool stop = FALSE;
 
-    /* FIXME: This should probably use a different lock, so that we	*/
-    /* become callable with or without the allocation lock.		*/
+    /* FIXME: This should probably use a different lock, so that we */
+    /* become callable with or without the allocation lock.   */
     LOCK();
       ++reentry_count;
     UNLOCK();
-    
+
 #   if NFRAMES == 1
       GC_err_printf0("\tCaller at allocation:\n");
 #   else
       GC_err_printf0("\tCall chain at allocation:\n");
 #   endif
     for (i = 0; i < NFRAMES && !stop ; i++) {
-     	if (info[i].ci_pc == 0) break;
-#	if NARGS > 0
-	{
-	  int j;
+      if (info[i].ci_pc == 0) break;
+# if NARGS > 0
+  {
+    int j;
 
-     	  GC_err_printf0("\t\targs: ");
-     	  for (j = 0; j < NARGS; j++) {
-     	    if (j != 0) GC_err_printf0(", ");
-     	    GC_err_printf2("%d (0x%X)", ~(info[i].ci_arg[j]),
-     	    				~(info[i].ci_arg[j]));
-     	  }
-	  GC_err_printf0("\n");
-	}
-# 	endif
+        GC_err_printf0("\t\targs: ");
+        for (j = 0; j < NARGS; j++) {
+          if (j != 0) GC_err_printf0(", ");
+          GC_err_printf2("%d (0x%X)", ~(info[i].ci_arg[j]),
+                  ~(info[i].ci_arg[j]));
+        }
+    GC_err_printf0("\n");
+  }
+#   endif
         if (reentry_count > 1) {
-	    /* We were called during an allocation during	*/
-	    /* a previous GC_print_callers call; punt.		*/
-     	    GC_err_printf1("\t\t##PC##= 0x%lx\n", info[i].ci_pc);
-	    continue;
-	}
-	{
-#	  ifdef LINUX
-	    FILE *pipe;
-#	  endif
-#	  if defined(GC_HAVE_BUILTIN_BACKTRACE) \
-	     && !defined(GC_BACKTRACE_SYMBOLS_BROKEN)
-	    char **sym_name =
-	      backtrace_symbols((void **)(&(info[i].ci_pc)), 1);
-	    char *name = sym_name[0];
-#	  else
-	    char buf[40];
-	    char *name = buf;
-     	    sprintf(buf, "##PC##= 0x%lx", info[i].ci_pc);
-#	  endif
-#	  if defined(LINUX) && !defined(SMALL_CONFIG)
-	    /* Try for a line number. */
-	    {
-#	        define EXE_SZ 100
-		static char exe_name[EXE_SZ];
-#		define CMD_SZ 200
-		char cmd_buf[CMD_SZ];
-#		define RESULT_SZ 200
-		static char result_buf[RESULT_SZ];
-		size_t result_len;
-		char *old_preload;
-#		define PRELOAD_SZ 200
-    		char preload_buf[PRELOAD_SZ];
-		static GC_bool found_exe_name = FALSE;
-		static GC_bool will_fail = FALSE;
-		int ret_code;
-		/* Try to get it via a hairy and expensive scheme.	*/
-		/* First we get the name of the executable:		*/
-		if (will_fail) goto out;
-		if (!found_exe_name) { 
-		  ret_code = readlink("/proc/self/exe", exe_name, EXE_SZ);
-		  if (ret_code < 0 || ret_code >= EXE_SZ
-		      || exe_name[0] != '/') {
-		    will_fail = TRUE;	/* Dont try again. */
-		    goto out;
-		  }
-		  exe_name[ret_code] = '\0';
-		  found_exe_name = TRUE;
-		}
-		/* Then we use popen to start addr2line -e <exe> <addr>	*/
-		/* There are faster ways to do this, but hopefully this	*/
-		/* isn't time critical.					*/
-		sprintf(cmd_buf, "/usr/bin/addr2line -f -e %s 0x%lx", exe_name,
-				 (unsigned long)info[i].ci_pc);
-		old_preload = getenv ("LD_PRELOAD");
-	        if (0 != old_preload) {
-		  if (strlen (old_preload) >= PRELOAD_SZ) {
-		    will_fail = TRUE;
-		    goto out;
-		  }
-		  strcpy (preload_buf, old_preload);
-		  unsetenv ("LD_PRELOAD");
-	        }
-		pipe = popen(cmd_buf, "r");
-		if (0 != old_preload
-		    && 0 != setenv ("LD_PRELOAD", preload_buf, 0)) {
-		  WARN("Failed to reset LD_PRELOAD\n", 0);
-      		}
-		if (pipe == NULL
-		    || (result_len = fread(result_buf, 1, RESULT_SZ - 1, pipe))
-		       == 0) {
-		  if (pipe != NULL) pclose(pipe);
-		  will_fail = TRUE;
-		  goto out;
-		}
-		if (result_buf[result_len - 1] == '\n') --result_len;
-		result_buf[result_len] = 0;
-		if (result_buf[0] == '?'
-		    || result_buf[result_len-2] == ':' 
-		       && result_buf[result_len-1] == '0') {
-		    pclose(pipe);
-		    goto out;
-		}
-		/* Get rid of embedded newline, if any.  Test for "main" */
-		{
-		   char * nl = strchr(result_buf, '\n');
-		   if (nl != NULL && nl < result_buf + result_len) {
-		     *nl = ':';
-		   }
-		   if (strncmp(result_buf, "main", nl - result_buf) == 0) {
-		     stop = TRUE;
-		   }
-		}
-		if (result_len < RESULT_SZ - 25) {
-		  /* Add in hex address	*/
-		    sprintf(result_buf + result_len, " [0x%lx]",
-			  (unsigned long)info[i].ci_pc);
-		}
-		name = result_buf;
-		pclose(pipe);
-		out:;
-	    }
-#	  endif /* LINUX */
-	  GC_err_printf1("\t\t%s\n", name);
-#	  if defined(GC_HAVE_BUILTIN_BACKTRACE) \
-	     && !defined(GC_BACKTRACE_SYMBOLS_BROKEN)
-	    free(sym_name);  /* May call GC_free; that's OK */
+      /* We were called during an allocation during */
+      /* a previous GC_print_callers call; punt.    */
+          GC_err_printf1("\t\t##PC##= 0x%lx\n", info[i].ci_pc);
+      continue;
+  }
+  {
+#   ifdef LINUX
+      FILE *pipe;
+#   endif
+#   if defined(GC_HAVE_BUILTIN_BACKTRACE) \
+       && !defined(GC_BACKTRACE_SYMBOLS_BROKEN)
+      char **sym_name =
+        backtrace_symbols((void **)(&(info[i].ci_pc)), 1);
+      char *name = sym_name[0];
+#   else
+      char buf[40];
+      char *name = buf;
+          sprintf(buf, "##PC##= 0x%lx", info[i].ci_pc);
+#   endif
+#   if defined(LINUX) && !defined(SMALL_CONFIG)
+      /* Try for a line number. */
+      {
+#         define EXE_SZ 100
+    static char exe_name[EXE_SZ];
+#   define CMD_SZ 200
+    char cmd_buf[CMD_SZ];
+#   define RESULT_SZ 200
+    static char result_buf[RESULT_SZ];
+    size_t result_len;
+    char *old_preload;
+#   define PRELOAD_SZ 200
+        char preload_buf[PRELOAD_SZ];
+    static GC_bool found_exe_name = FALSE;
+    static GC_bool will_fail = FALSE;
+    int ret_code;
+    /* Try to get it via a hairy and expensive scheme.  */
+    /* First we get the name of the executable:   */
+    if (will_fail) goto out;
+    if (!found_exe_name) {
+      ret_code = readlink("/proc/self/exe", exe_name, EXE_SZ);
+      if (ret_code < 0 || ret_code >= EXE_SZ
+          || exe_name[0] != '/') {
+        will_fail = TRUE; /* Dont try again. */
+        goto out;
+      }
+      exe_name[ret_code] = '\0';
+      found_exe_name = TRUE;
+    }
+    /* Then we use popen to start addr2line -e <exe> <addr> */
+    /* There are faster ways to do this, but hopefully this */
+    /* isn't time critical.         */
+    sprintf(cmd_buf, "/usr/bin/addr2line -f -e %s 0x%lx", exe_name,
+         (unsigned long)info[i].ci_pc);
+    old_preload = getenv ("LD_PRELOAD");
+          if (0 != old_preload) {
+      if (strlen (old_preload) >= PRELOAD_SZ) {
+        will_fail = TRUE;
+        goto out;
+      }
+      strcpy (preload_buf, old_preload);
+      unsetenv ("LD_PRELOAD");
+          }
+    pipe = popen(cmd_buf, "r");
+    if (0 != old_preload
+        && 0 != setenv ("LD_PRELOAD", preload_buf, 0)) {
+      WARN("Failed to reset LD_PRELOAD\n", 0);
+          }
+    if (pipe == NULL
+        || (result_len = fread(result_buf, 1, RESULT_SZ - 1, pipe))
+           == 0) {
+      if (pipe != NULL) pclose(pipe);
+      will_fail = TRUE;
+      goto out;
+    }
+    if (result_buf[result_len - 1] == '\n') --result_len;
+    result_buf[result_len] = 0;
+    if (result_buf[0] == '?'
+        || result_buf[result_len-2] == ':'
+           && result_buf[result_len-1] == '0') {
+        pclose(pipe);
+        goto out;
+    }
+    /* Get rid of embedded newline, if any.  Test for "main" */
+    {
+       char * nl = strchr(result_buf, '\n');
+       if (nl != NULL && nl < result_buf + result_len) {
+         *nl = ':';
+       }
+       if (strncmp(result_buf, "main", nl - result_buf) == 0) {
+         stop = TRUE;
+       }
+    }
+    if (result_len < RESULT_SZ - 25) {
+      /* Add in hex address */
+        sprintf(result_buf + result_len, " [0x%lx]",
+        (unsigned long)info[i].ci_pc);
+    }
+    name = result_buf;
+    pclose(pipe);
+    out:;
+      }
+#   endif /* LINUX */
+    GC_err_printf1("\t\t%s\n", name);
+#   if defined(GC_HAVE_BUILTIN_BACKTRACE) \
+       && !defined(GC_BACKTRACE_SYMBOLS_BROKEN)
+      free(sym_name);  /* May call GC_free; that's OK */
 #         endif
-	}
+  }
     }
     LOCK();
       --reentry_count;
Index: external/libregex38a/include/regex38a.h
===================================================================
--- external/libregex38a/include/regex38a.h	(revision 6634)
+++ external/libregex38a/include/regex38a.h	(working copy)
@@ -1,6 +1,7 @@
-#ifndef _REGEX_H_
-#define	_REGEX_H_	/* never again */
+#ifndef _CUB_REGEX_H_
+#define	_CUB_REGEX_H_	/* never again */
 /* ========= begin header generated by ./mkh ========= */
+#include <sys/types.h>
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -11,16 +12,20 @@
 
 /* === regex2.h === */
 typedef off_t cub_regoff_t;
-typedef struct {
+typedef struct CUB_REGEX cub_regex_t;
+typedef struct CUB_REGMATCH cub_regmatch_t;
+
+struct CUB_REGEX{
 	int re_magic;
 	size_t re_nsub;		/* number of parenthesized subexpressions */
 	const char *re_endp;	/* end pointer for CUB_REG_PEND */
 	struct cub_re_guts *re_g;	/* none of your business :-) */
-} cub_regex_t;
-typedef struct {
+};
+
+typedef struct CUB_REGMATCH{
 	cub_regoff_t rm_so;		/* start of match */
 	cub_regoff_t rm_eo;		/* end of match */
-} cub_regmatch_t;
+};
 
 
 /* === regcomp.c === */
